# Zolt-Jolt Compatibility: Status Update

## Status: DEBUGGING STAGE 4 FINAL CLAIM MISMATCH

## Summary

Zolt can now:
1. Generate proofs for RISC-V programs (`./zig-out/bin/zolt prove`)
2. Verify proofs internally (`./zig-out/bin/zolt verify`) - ALL 6 STAGES PASS
3. Export proofs in Jolt-compatible format (`--jolt-format`)
4. Export preprocessing for Jolt verifier (`--export-preprocessing`)
5. Pass all 714 unit tests ✓
6. **Proof successfully deserializes in Jolt** ✓
7. **Preprocessing successfully deserializes in Jolt** ✓

## Cross-Verification Status

Using pre-built Jolt test binary:

```
✓ test_deserialize_zolt_proof - PASSED
✓ test_load_zolt_preprocessing - PASSED
✗ test_verify_zolt_proof_with_zolt_preprocessing - FAILS at Stage 4
```

## Recent Fixes (This Session)

### 1. Phase Structure Fix for RWC (read_write_checking.zig)
- Added `phase1_num_rounds` parameter to match batched sumcheck's 3-phase structure
- Updated `bindChallenge`, `computePhase2Polynomial`, `getOpeningClaims` to use correct phase boundaries
- **Result**: `input_claim_val_eval` went from non-zero to ZERO (correct for Fibonacci!)

### 2. Removed Termination Bit Workaround from val_init (output_check.zig)
- `val_init` should NOT include termination bit (matches Jolt verifier's `eval_initial_ram_mle`)
- Only `val_final` should have termination bit set
- **Result**: `init_eval_for_val_final` now matches verifier computation

### 3. Added Synthetic Termination Write to Tracer (tracer/mod.zig)
- Records a write to termination address when program terminates (via ECALL or infinite loop)
- This is needed because Zolt guest programs don't have Jolt SDK macro that generates this write
- **Result**: RAM trace now includes termination write contribution

### 4. Fixed r_address Extraction for init_eval_for_val_final (proof_converter.zig)
- Uses OutputSumcheck's sumcheck challenges (last log_ram_k Stage 2 challenges), not r_address_raf
- The challenges are reversed to match `normalize_opening_point` (LE to BE conversion)
- **Result**: `init_eval_for_val_final` is computed at the correct point

## Current Issue

Stage 4 verification still fails: `expected_output ≠ batched_claim`

After adding the termination write:
- `input_claim_val_eval` is now NON-ZERO (because termination write contributes to inc * wa sum)
- `input_claim_val_final` is NON-ZERO (same reason)

The issue is that the **input_claims computed from opening values** don't match the **actual polynomial sums** computed by the provers.

For the sumcheck to verify:
- `input_claim` must equal the sum of the polynomial over all j
- Prover computes the actual sum
- These must match

## Key Insight from Jolt Analysis

In Jolt:
- The guest program writes to termination address via SB instruction (generated by SDK macro)
- This write IS recorded in the RAM trace
- The `inc` and `wa` polynomials have contributions from this write
- `val_final - val_init = Σ inc * wa` balances at the termination address

In Zolt (after fixes):
- The tracer injects a synthetic termination write when program terminates
- The `inc` polynomial should have inc[termination_cycle] = 1 (post - pre = 1 - 0)
- The `wa` polynomial should have wa contribution at the termination address

## Next Steps

1. **Verify polynomial sums match input claims**:
   - Check if ValEvaluation and ValFinal provers compute sums that equal the input claims
   - The input_claim formula: `claimed_evaluation - init_eval`
   - The prover sum: `Σ_j f(j)` where f is the sumcheck polynomial

2. **Check termination write cycle index**:
   - Ensure the termination write cycle is within the trace bounds
   - Verify the inc and wa polynomials are populated correctly

3. **Debug the expected_output computation**:
   - The eq_eval and combined claims may need adjustment

## Files Generated

- `/tmp/fib_proof.bin` - Zolt native format proof
- `/tmp/zolt_proof_dory.bin` - Jolt-compatible format proof
- `/tmp/zolt_preprocessing.bin` - Preprocessing for Jolt verifier

## Test Commands

```bash
# Run full verification (fails at Stage 4)
./zig-out/bin/zolt prove examples/fibonacci.elf -o /tmp/fib_proof.bin \
    --jolt-format /tmp/zolt_proof_dory.bin \
    --export-preprocessing /tmp/zolt_preprocessing.bin 2>&1 | \
    grep -E "STAGE4|input_claim|Do they match"
```

SESSION_ENDING: Made significant progress on Stage 4 - fixed phase structure, termination bit workaround, and termination write injection. The issue now is that input_claims don't match prover sums after adding termination write.
