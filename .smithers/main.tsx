#!/usr/bin/env bun
/** @jsxImportSource smithers-orchestrator */
import { createSmithersRoot } from 'smithers-orchestrator'
import { createSmithersDB } from 'smithers-orchestrator/db'
import {
  Ralph,
  SmithersProvider,
  Claude,
  Phase,
  Step,
} from 'smithers-orchestrator/components'

/**
 * Smithers Orchestration Template
 *
 * Declarative AI agent workflow using the Smithers framework.
 * ALL STATE LIVES IN SQLITE - fully auditable, recoverable, and predictable.
 *
 * Run with:
 *   bunx smithers-orchestrator monitor
 */

// ============================================================================
// DATABASE SETUP - ALL DURABLE STATE LIVES HERE (SQLite)
// ============================================================================

const db = await createSmithersDB({
  path: '.smithers/data.db',
})

const executionId = await db.execution.start(
  'Zolt-Jolt Compatibility',
  '.smithers/main.tsx',
  {
    maxIterations: 20,
    model: 'sonnet',
  }
)

// ============================================================================
// ORCHESTRATION DEFINITION
// ============================================================================

async function App() {
  return (
    <SmithersProvider
      db={db}
      executionId={executionId}
      maxIterations={10}
      globalTimeout={1800000}
      snapshotOnStart
      stopConditions={[
        { type: 'total_tokens', value: 500000, message: 'Token budget exceeded' }
      ]}
      onComplete={() => console.log('Orchestration complete')}
      onError={(err) => console.error('Orchestration error:', err)}
    >
      <Ralph>
        {/* ============================================================ */}
        {/* PHASE 1: INVESTIGATE                                         */}
        {/* Understand current state and identify mismatches             */}
        {/* ============================================================ */}
        <Phase
          name="Investigate"
          onStart={() => console.log('Starting investigation phase')}
          onComplete={() => console.log('Investigation complete')}
        >
          <Step name="analyze-mismatch">
            <Claude
              model="sonnet"
              reportingEnabled
              allowedTools={['Read', 'Bash', 'Glob', 'Grep']}
              stopConditions={[
                { type: 'turn_limit', value: 30 },
                { type: 'token_limit', value: 80000 },
              ]}
            >
              {"Analyze the Zolt codebase to understand why proofs generated by Zolt don't verify in Jolt. Look at test outputs, debug logs, and compare implementations. Report findings clearly."}
            </Claude>
          </Step>
        </Phase>

        {/* ============================================================ */}
        {/* PHASE 2: FIX                                                 */}
        {/* Implement fixes based on investigation                       */}
        {/* ============================================================ */}
        <Phase
          name="Fix"
          onStart={() => console.log('Starting fix phase')}
          onComplete={() => console.log('Fix phase complete')}
        >
          <Step name="implement-fix">
            <Claude
              model="sonnet"
              reportingEnabled
              allowedTools={['Read', 'Edit', 'Write', 'Bash', 'Glob', 'Grep']}
              stopConditions={[
                { type: 'turn_limit', value: 50 },
                { type: 'token_limit', value: 150000 },
              ]}
            >
              {"Based on the investigation, fix Zolt so that proofs it generates verify correctly in Jolt. Make minimal targeted changes."}
            </Claude>
          </Step>
        </Phase>

        {/* ============================================================ */}
        {/* PHASE 3: VERIFY                                              */}
        {/* Generate proof in Zolt, verify in Jolt                       */}
        {/* ============================================================ */}
        <Phase
          name="Verify"
          onStart={() => console.log('Starting verification phase')}
          onComplete={() => console.log('Verification complete')}
        >
          <Step name="test-compatibility">
            <Claude
              model="sonnet"
              allowedTools={['Bash', 'Read', 'Grep']}
              stopConditions={[{ type: 'turn_limit', value: 20 }]}
              onFinished={(result) => {
                const passed = result.output.includes('verification succeeded') ||
                               result.output.includes('PASS')
                console.log(passed ? 'Zolt-Jolt compatibility verified!' : 'Verification failed')
              }}
            >
              {"Run the Zolt-Jolt compatibility test: generate a proof with Zolt and verify it with Jolt. Report success or failure with details."}
            </Claude>
          </Step>
        </Phase>

        {/* ============================================================ */}
        {/* PHASE 4: FINALIZE                                            */}
        {/* ============================================================ */}
        <Phase
          name="Finalize"
          onStart={() => console.log('Starting finalize phase')}
          onComplete={() => console.log('Zolt-Jolt compatibility achieved!')}
        />
      </Ralph>

    </SmithersProvider>
  )
}

// ============================================================================
// EXECUTION
// ============================================================================

async function main() {
  const root = createSmithersRoot()

  try {
    console.log('╔══════════════════════════════════════════════════════════╗')
    console.log('║            SMITHERS ORCHESTRATION PLAN                   ║')
    console.log('╚══════════════════════════════════════════════════════════╝')
    console.log('')
    console.log('Database: .smithers/data (SQLite)')
    console.log('Execution ID:', executionId)
    console.log('')
    console.log('To inspect:')
    console.log('  bunx smithers-orchestrator db state')
    console.log('  bunx smithers-orchestrator db commits')
    console.log('  bunx smithers-orchestrator db reviews')
    console.log('  bunx smithers-orchestrator db reports')
    console.log('')
    console.log('═══════════════════════════════════════════════════════════')
    console.log('')

    await root.mount(App)
    root.dispose()

    const finalState = await db.state.getAll()
    await db.execution.complete(executionId, finalState)

    console.log('')
    console.log('✅ Execution complete!')

    const execution = await db.execution.get(executionId)
    if (execution) {
      console.log('Summary:')
      console.log(`  Duration: ${execution.completed_at
        ? new Date(execution.completed_at).getTime() - new Date(execution.started_at!).getTime()
        : 0}ms`)
      console.log(`  Agents: ${execution.total_agents}`)
      console.log(`  Tool calls: ${execution.total_tool_calls}`)
      console.log(`  Tokens: ${execution.total_tokens_used}`)
    }

  } catch (error) {
    console.error('')
    console.error('❌ Execution failed:', error)

    root.dispose()
    await db.execution.fail(
      executionId,
      error instanceof Error ? error.message : String(error)
    )

    process.exit(1)
  } finally {
    await db.close()
  }
}

main().catch(console.error)
