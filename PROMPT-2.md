# Zolt-Jolt Compatibility Implementation Guide

You are an AI agent tasked with making the Zolt zkVM (Zig) produce proofs that can be verified by the Jolt zkVM (Rust). This is a cross-language cryptographic compatibility project requiring precise byte-level alignment.

## Project Locations

- **Zolt** (Zig): `/Users/matteo/projects/zolt`
- **Jolt** (Rust): `/Users/matteo/projects/jolt`
- **Zig Reference** (0.15.2): `/Users/matteo/projects/zolt/zig` - consult when Zig behavior is unclear

## Goal

Enable this workflow:
```
[Zolt Prover] --generates--> [Proof] --verified-by--> [Jolt Verifier]
```

A proof generated by `zolt prove program.elf -o proof.bin` should be verifiable by Jolt's verification logic.

---

## CRITICAL: Compatibility Requirements

### 1. Transcript Alignment (HIGHEST PRIORITY)

The Fiat-Shamir transcript is THE most critical component. If challenges differ by even 1 bit, verification fails.

**Jolt's Blake2b Transcript** (`jolt-core/src/transcripts/blake2b.rs`):
```rust
pub struct Blake2bTranscript {
    pub state: [u8; 32],    // 256-bit state
    n_rounds: u32,          // Round counter for domain separation
}

// Initialization: Blake2b(label padded to 32 bytes)
// Append scalar: serialize LE, reverse to BE, hash with state + round
// Challenge: hash and extract, challenges are 128-bit
```

**Zolt's Keccak Transcript** (`src/transcripts/mod.zig`):
```zig
state: [KECCAK_STATE_SIZE]u8,  // 200-byte state
position: usize,
domain: []const u8,
// Scalars serialized little-endian
// Full Keccak-f[1600] permutation
```

**Required Changes in Zolt**:
1. Replace Keccak with Blake2b-256
2. Use 32-byte state representation
3. Add round counter that increments on each hash operation
4. Implement EVM-compatible scalar serialization (LE serialize, then reverse to BE)
5. Match Jolt's label padding (right-pad to 32 bytes with zeros)
6. Match Jolt's vector append format (begin_append_vector/end_append_vector markers)

**Implementation Location**: `src/transcripts/mod.zig` - create new `Blake2bTranscript` type

### 2. Proof Structure Mapping

**Jolt's 7-Stage Proof** (`jolt-core/src/zkvm/proof_serialization.rs`):
```rust
pub struct JoltProof<F, PCS, FS> {
    pub opening_claims: Claims<F>,
    pub commitments: Vec<PCS::Commitment>,
    pub stage1_uni_skip_first_round_proof: UniSkipFirstRoundProof<F, FS>,
    pub stage1_sumcheck_proof: SumcheckInstanceProof<F, FS>,
    pub stage2_uni_skip_first_round_proof: UniSkipFirstRoundProof<F, FS>,
    pub stage2_sumcheck_proof: SumcheckInstanceProof<F, FS>,
    pub stage3_sumcheck_proof: SumcheckInstanceProof<F, FS>,
    pub stage4_sumcheck_proof: SumcheckInstanceProof<F, FS>,
    pub stage5_sumcheck_proof: SumcheckInstanceProof<F, FS>,
    pub stage6_sumcheck_proof: SumcheckInstanceProof<F, FS>,
    pub stage7_sumcheck_proof: SumcheckInstanceProof<F, FS>,
    pub joint_opening_proof: PCS::Proof,
    // ... advice proofs and config
    pub trace_length: usize,
    pub ram_K: usize,
    pub bytecode_K: usize,
    pub log_k_chunk: usize,
    pub lookups_ra_virtual_log_k_chunk: usize,
}
```

**Zolt's 6-Stage Proof** (`src/zkvm/mod.zig`):
```zig
pub fn JoltProof(comptime F: type) type {
    return struct {
        bytecode_proof: bytecode.BytecodeProof(F),
        memory_proof: ram.MemoryProof(F),
        register_proof: registers.RegisterProof(F),
        r1cs_proof: spartan.R1CSProof(F),
        stage_proofs: ?JoltStageProofs(F),
    };
}
```

**Required Changes**:
1. Restructure `JoltProof` to match Jolt's 7-stage layout
2. Add `UniSkipFirstRoundProof` for stages 1 and 2
3. Separate stage_proofs into individual stage1-7 sumcheck proofs
4. Add `opening_claims` as a BTreeMap-like structure
5. Add all configuration parameters (trace_length, ram_K, etc.)

### 3. Serialization Format

**Jolt uses Arkworks Canonical Serialization**:
- Field elements: 32 bytes little-endian (Montgomery form limbs)
- Points: Compressed G1 (32 or 33 bytes) or uncompressed (64 bytes)
- Lengths: usize as u64 (8 bytes)
- BTreeMap: length prefix + sorted key-value pairs

**Required Changes in Zolt** (`src/zkvm/serialization.zig`):
1. Remove "ZOLT" magic header (Jolt has no magic)
2. Implement arkworks-compatible field element serialization
3. Implement arkworks-compatible point serialization (G1Affine format)
4. Match usize encoding (u64 little-endian)
5. Implement OpeningId compact encoding scheme (see below)

**OpeningId Encoding** (from `proof_serialization.rs`):
```
NUM_SUMCHECKS = 11
BASE = 2 * NUM_SUMCHECKS = 22

UntrustedAdvice(sumcheck_id) -> sumcheck_id
TrustedAdvice(sumcheck_id) -> NUM_SUMCHECKS + sumcheck_id
Committed(poly, sumcheck_id) -> BASE + sumcheck_id + poly_index * NUM_SUMCHECKS
Virtual(poly, sumcheck_id) -> BASE + committed_count * NUM_SUMCHECKS + ...
```

### 4. Commitment Scheme Alignment

**Jolt uses Dory as primary PCS**:
```rust
pub struct DoryCommitmentScheme;
impl CommitmentScheme for DoryCommitmentScheme {
    type Field = ark_bn254::Fr;
    type Commitment = ArkGT;  // Target group element (Fp12)
    type Proof = ArkDoryProof;
}
```

**Implementation in Zolt** (Recommended: Complete Dory):
- Implement streaming Dory commitment from `jolt-core/src/poly/commitment/dory/`
- Use same SRS generation (SHA3-256 seed: `"Jolt Dory URS seed"`)
- Match GT element serialization (Fp12 in arkworks format)

### 5. Sumcheck Protocol Alignment

**Jolt's SumcheckInstanceProof** (`jolt-core/src/subprotocols/sumcheck.rs`):
```rust
pub struct SumcheckInstanceProof<F: JoltField, FS: Transcript> {
    pub(crate) round_polys: Vec<(Vec<F>, FS::Challenge)>,
    pub(crate) _transcript: PhantomData<FS>,
}
```

**UniSkipFirstRoundProof** (stages 1 and 2 only):
```rust
pub struct UniSkipFirstRoundProof<F: JoltField, FS: Transcript> {
    pub(crate) claim: F,
    _marker: PhantomData<FS>,
}
```

**Required Changes in Zolt** (`src/subprotocols/mod.zig`):
1. Match round polynomial format: Vec of (coefficients, challenge) pairs
2. Add UniSkipFirstRoundProof structure for first two stages
3. Ensure degree bounds match (degree 3 for most, degree 2 for some)

### 6. Field Element Compatibility

Both use BN254 scalar field with same modulus:
```
p = 21888242871839275222246405745257275088548364400416034343698204186575808495617
```

**Verification**: Zolt's `BN254Scalar` (`src/field/mod.zig`) should produce identical byte representations as arkworks when serialized.

**Test**: Serialize same field element in both, compare bytes.

---

## Implementation Phases

### Phase 1: Transcript Compatibility

1. **Create Blake2bTranscript in Zolt**
   - File: `src/transcripts/blake2b.zig`
   - Port Blake2b-256 hash function
   - Implement 32-byte state with round counter
   - Match Jolt's append/challenge methods exactly

2. **Test Vector Validation**
   - Create test vectors in Jolt: append known values, extract challenges
   - Verify Zolt produces identical challenges
   - Critical: Both must derive same Fiat-Shamir challenges for same inputs

### Phase 2: Proof Structure Refactoring

1. **Restructure JoltProof**
   - File: `src/zkvm/mod.zig`
   - Add 7 explicit stage proof fields
   - Add UniSkipFirstRoundProof fields
   - Add opening_claims BTreeMap

2. **Refactor Prover**
   - File: `src/zkvm/prover.zig`
   - Generate UniSkipFirstRoundProof for stages 1-2
   - Populate opening_claims correctly
   - Match stage ordering with Jolt

### Phase 3: Serialization Alignment

1. **Implement Arkworks-Compatible Serialization**
   - File: `src/zkvm/serialization.zig`
   - Remove ZOLT magic header
   - Match arkworks field element format
   - Match OpeningId encoding scheme

2. **Create Format Converter (Optional)**
   - Tool to convert existing ZOLT proofs to Jolt format
   - Useful for migration

### Phase 4: Commitment Scheme

1. **Complete Dory Implementation**
   - File: `src/poly/commitment/dory.zig`
   - Match Jolt's Dory format exactly
   - Use same SRS generation seed
   - Serialize GT elements in arkworks format

### Phase 5: Integration Testing

1. **Cross-Verification Tests**
   - Generate proof in Zolt
   - Load and verify in Jolt
   - Test with multiple programs

2. **Round-Trip Tests**
   - Serialize in Zolt, deserialize in Jolt
   - Verify proof structure integrity

---

## Key Reference Files

### Zolt (Modify These)
| File | Purpose |
|------|---------|
| `src/transcripts/mod.zig` | Add Blake2bTranscript |
| `src/zkvm/mod.zig` | Restructure JoltProof |
| `src/zkvm/prover.zig` | 7-stage prover |
| `src/zkvm/serialization.zig` | Arkworks format |
| `src/poly/commitment/mod.zig` | Complete Dory |

### Jolt (Reference Only - No Modifications)
| File | Purpose |
|------|---------|
| `jolt-core/src/transcripts/blake2b.rs` | Transcript implementation |
| `jolt-core/src/zkvm/proof_serialization.rs` | Proof structure |
| `jolt-core/src/zkvm/verifier.rs` | 8-stage verification |
| `jolt-core/src/subprotocols/sumcheck.rs` | Sumcheck format |
| `jolt-core/src/poly/commitment/dory/` | Dory commitment |

---

## Testing Strategy

### Unit Tests
1. **Transcript Tests**: Same inputs -> same challenges
2. **Field Tests**: Same element -> same bytes
3. **Commitment Tests**: Same polynomial -> same commitment

### Integration Tests
1. Generate proof in Zolt for `fibonacci.elf`
2. Save proof in Jolt-compatible format
3. Load proof in Jolt verifier
4. Verify returns success

### Test Commands
```bash
# Zolt side
cd /Users/matteo/projects/zolt
zig build test  # All 578 tests should pass
zig build -Doptimize=ReleaseFast
./zig-out/bin/zolt prove examples/fibonacci/fibonacci.elf -o proof.jolt

# Jolt side
cd /Users/matteo/projects/jolt
cargo test
# Add integration test that loads proof.jolt and verifies
```

---

## Important Notes

### Zig 0.15.2 Reference
The Zig source is at `/Users/matteo/projects/zolt/zig`. Consult this when:
- Zig behavior seems incorrect
- Need to understand std library implementation
- Encounter compiler issues

### Jolt Toolchain
You have access to the full Jolt toolchain. Use it to:
- Generate reference test vectors
- Verify your format changes work
- Debug serialization issues

### Commit Strategy
Make frequent commits after each small advancement:
```bash
git add -A && git commit -m "feat: implement Blake2b transcript"
git push
```

### Notes Location
Store implementation notes in `.agent/NOTES.md` and track progress in `.agent/TODO.md`.

---

## Success Criteria

The implementation is complete when:
1. `zig build test` passes all 578+ tests
2. Zolt can generate a proof for any example program
3. The proof can be loaded and verified by Jolt's verifier
4. No modifications needed on the Jolt side

## Priority Order

1. **Transcript** - Without this, nothing else matters
2. **Proof Structure** - Must match Jolt's expectations
3. **Serialization** - Byte-perfect compatibility required
4. **Commitment Scheme** - Complete Dory implementation
5. **Integration Tests** - Validate end-to-end flow
