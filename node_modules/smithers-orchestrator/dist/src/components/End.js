import { jsx as _jsx } from "react/jsx-runtime";
import { useRef } from 'react';
import { useSmithers } from './SmithersProvider.js';
import { useMount } from '../reconciler/hooks.js';
/**
 * End component - explicitly terminates orchestration and captures structured summary.
 *
 * When rendered, it:
 * 1. Evaluates the summary (sync or async)
 * 2. Stores summary in executions table
 * 3. Calls requestStop() to halt Ralph loop
 * 4. Process exits with exitCode
 *
 * @example
 * ```tsx
 * <End
 *   summary={{
 *     status: 'success',
 *     message: 'PR #123 review completed',
 *     data: { iterations: 2, approved: true },
 *   }}
 * />
 * ```
 *
 * @example Dynamic summary
 * ```tsx
 * <End
 *   summary={async () => {
 *     const review = await db.state.get('lastReview')
 *     return {
 *       status: review?.approved ? 'success' : 'failure',
 *       message: review?.approved ? 'Approved' : 'Changes requested',
 *     }
 *   }}
 * />
 * ```
 */
export function End(props) {
    const { db, executionId, requestStop } = useSmithers();
    const taskIdRef = useRef(null);
    const hasEndedRef = useRef(false);
    useMount(() => {
        if (hasEndedRef.current)
            return;
        hasEndedRef.current = true;
        (async () => {
            taskIdRef.current = db.tasks.start('end', 'orchestration');
            try {
                // Evaluate summary
                const summary = typeof props.summary === 'function'
                    ? await props.summary()
                    : props.summary;
                const reason = props.reason ?? (summary.status === 'success' ? 'success' : 'failure');
                const exitCode = props.exitCode ?? (summary.status === 'success' ? 0 : 1);
                // Store in DB
                db.db.run(`
          UPDATE executions 
          SET end_summary = ?, end_reason = ?, exit_code = ?, status = 'completed'
          WHERE id = ?
        `, [JSON.stringify(summary), reason, exitCode, executionId]);
                // Signal stop
                requestStop(`End: ${summary.message}`);
                db.tasks.complete(taskIdRef.current);
            }
            catch (error) {
                if (taskIdRef.current) {
                    db.tasks.complete(taskIdRef.current);
                }
                throw error;
            }
        })();
    });
    const reason = props.reason ??
        (typeof props.summary === 'function'
            ? 'pending'
            : props.summary.status === 'success'
                ? 'success'
                : 'failure');
    return (_jsx("end", { status: "ending", reason: reason, exitCode: props.exitCode ?? 0 }));
}
//# sourceMappingURL=End.js.map