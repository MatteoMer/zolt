import { jsx as _jsx } from "react/jsx-runtime";
import { useRef } from 'react';
import { useSmithers } from '../SmithersProvider.js';
import { addGitNotes, getGitNotes } from '../../utils/vcs.js';
import { useMountedState, useExecutionMount } from '../../reconciler/hooks.js';
import { useQueryValue } from '../../reactive-sqlite/index.js';
import { useExecutionContext } from '../ExecutionContext.js';
/**
 * Notes component - adds/appends git notes with smithers tracking
 *
 * React pattern: Uses useEffect with empty deps and async IIFE inside
 */
export function Notes(props) {
    const smithers = useSmithers();
    const execution = useExecutionContext();
    const opIdRef = useRef(crypto.randomUUID());
    const stateKey = `git-notes:${opIdRef.current}`;
    const { data: opState } = useQueryValue(smithers.db.db, "SELECT value FROM state WHERE key = ?", [stateKey]);
    const defaultState = { status: 'pending', result: null, error: null };
    const { status, result, error } = (() => {
        if (!opState)
            return defaultState;
        try {
            return JSON.parse(opState);
        }
        catch {
            return defaultState;
        }
    })();
    const taskIdRef = useRef(null);
    const isMounted = useMountedState();
    const setState = (newState) => {
        smithers.db.state.set(stateKey, newState, 'git-notes');
    };
    const shouldExecute = smithers.executionEnabled && execution.isActive;
    useExecutionMount(shouldExecute, () => {
        // Fire-and-forget async IIFE
        ;
        (async () => {
            // Register task with database
            taskIdRef.current = smithers.db.tasks.start('git-notes');
            try {
                setState({ status: 'running', result: null, error: null });
                const commitRef = props.commitRef ?? 'HEAD';
                // Get existing notes if appending
                const previousNotes = props.append ? await getGitNotes(commitRef) : null;
                // Prepare notes content with smithers metadata
                const notesData = {
                    smithers: true,
                    executionId: smithers.executionId,
                    timestamp: Date.now(),
                    ...props.data,
                };
                const notesContent = JSON.stringify(notesData, null, 2);
                // Add or append notes
                await addGitNotes(notesContent, commitRef, props.append ?? false);
                const notesResult = {
                    commitRef,
                    data: notesData,
                    previousNotes,
                };
                if (isMounted()) {
                    setState({ status: 'complete', result: notesResult, error: null });
                    props.onFinished?.(notesResult);
                }
            }
            catch (err) {
                if (isMounted()) {
                    const errorObj = err instanceof Error ? err : new Error(String(err));
                    setState({ status: 'error', result: null, error: errorObj.message });
                    props.onError?.(errorObj);
                }
            }
            finally {
                // Complete task
                if (taskIdRef.current && isMounted()) {
                    smithers.db.tasks.complete(taskIdRef.current);
                }
            }
        })();
    }, [props.append, props.commitRef, props.data, props.onError, props.onFinished, smithers]);
    return (_jsx("git-notes", { status: status, "commit-ref": result?.commitRef, error: error }));
}
//# sourceMappingURL=Notes.js.map