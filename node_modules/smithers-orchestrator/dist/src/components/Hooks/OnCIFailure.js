import { jsx as _jsx } from "react/jsx-runtime";
// OnCIFailure hook component - polls CI status and triggers children on failure
// Currently supports GitHub Actions
import { useRef } from 'react';
import { useSmithers } from '../SmithersProvider.js';
import { useUnmount, useExecutionMount } from '../../reconciler/hooks.js';
import { useQueryValue } from '../../reactive-sqlite/index.js';
import { useExecutionContext } from '../ExecutionContext.js';
/**
 * Fetch the latest GitHub Actions run for the main branch
 */
async function fetchLatestGitHubActionsRun() {
    try {
        const result = await Bun.$ `gh run list --branch main --limit 1 --json status,conclusion,databaseId,name`.json();
        if (Array.isArray(result) && result.length > 0) {
            return result[0];
        }
        return null;
    }
    catch (err) {
        console.error('[OnCIFailure] Failed to fetch GitHub Actions status:', err);
        return null;
    }
}
/**
 * Fetch failed job names from a GitHub Actions run
 */
async function fetchFailedJobs(runId) {
    try {
        const result = await Bun.$ `gh run view ${runId} --json jobs`.json();
        if (result.jobs) {
            return result.jobs
                .filter((job) => job.conclusion === 'failure')
                .map((job) => job.name);
        }
        return [];
    }
    catch {
        return [];
    }
}
/**
 * Fetch logs from a failed GitHub Actions run
 */
async function fetchRunLogs(runId) {
    try {
        const result = await Bun.$ `gh run view ${runId} --log-failed 2>/dev/null`.text();
        // Truncate if too long (keep last 5000 chars)
        if (result.length > 5000) {
            return '... [truncated]\n' + result.slice(-5000);
        }
        return result;
    }
    catch {
        return '';
    }
}
const DEFAULT_CI_STATE = {
    ciStatus: 'idle',
    currentFailure: null,
    triggered: false,
    error: null,
    processedRunIds: [],
};
export function OnCIFailure(props) {
    const { db, reactiveDb, executionEnabled } = useSmithers();
    const execution = useExecutionContext();
    // Query state from db.state reactively
    const { data: stateJson } = useQueryValue(reactiveDb, "SELECT value FROM state WHERE key = 'hook:ciFailure'");
    const state = (() => {
        if (!stateJson)
            return DEFAULT_CI_STATE;
        try {
            return JSON.parse(stateJson);
        }
        catch {
            return DEFAULT_CI_STATE;
        }
    })();
    const { ciStatus, currentFailure, triggered, error } = state;
    const taskIdRef = useRef(null);
    const intervalMs = props.pollInterval ?? 30000;
    const pollIntervalRef = useRef(null);
    const shouldExecute = executionEnabled && execution.isActive;
    useExecutionMount(shouldExecute, () => {
        // Initialize state if not present
        const currentState = db.state.get('hook:ciFailure');
        if (!currentState) {
            db.state.set('hook:ciFailure', DEFAULT_CI_STATE, 'ci-failure-init');
        }
        // Fire-and-forget async IIFE pattern
        ;
        (async () => {
            const s = db.state.get('hook:ciFailure') ?? DEFAULT_CI_STATE;
            db.state.set('hook:ciFailure', { ...s, ciStatus: 'polling' }, 'ci-failure-polling');
            // Define the polling function
            const checkCI = async () => {
                try {
                    if (props.provider !== 'github-actions') {
                        const currentS = db.state.get('hook:ciFailure') ?? DEFAULT_CI_STATE;
                        db.state.set('hook:ciFailure', {
                            ...currentS,
                            error: `Unsupported CI provider: ${props.provider}`
                        }, 'ci-failure-error');
                        return;
                    }
                    const run = await fetchLatestGitHubActionsRun();
                    if (!run) {
                        return;
                    }
                    const currentS = db.state.get('hook:ciFailure') ?? DEFAULT_CI_STATE;
                    const processedSet = new Set(currentS.processedRunIds);
                    // Check if this is a new failure
                    if (run.status === 'completed' &&
                        run.conclusion === 'failure' &&
                        !processedSet.has(run.databaseId)) {
                        // Fetch additional failure details
                        const failedJobs = await fetchFailedJobs(run.databaseId);
                        const logs = await fetchRunLogs(run.databaseId);
                        const failure = {
                            failed: true,
                            runId: String(run.databaseId),
                            workflowName: run.name,
                            failedJobs,
                            logs,
                        };
                        // Update state with new failure and processed ID
                        db.state.set('hook:ciFailure', {
                            ...currentS,
                            ciStatus: 'failed',
                            currentFailure: failure,
                            triggered: true,
                            processedRunIds: [...currentS.processedRunIds, run.databaseId],
                        }, 'ci-failure-triggered');
                        // Call onFailure callback
                        props.onFailure?.(failure);
                        // Register task for tracking - children will handle completion
                        taskIdRef.current = db.tasks.start('ci-failure-hook');
                        // Complete immediately as children handle their own task registration
                        db.tasks.complete(taskIdRef.current);
                        // Log to db state
                        db.state.set('last_ci_failure', failure, 'ci-failure-hook');
                    }
                }
                catch (err) {
                    const errorMsg = err instanceof Error ? err.message : String(err);
                    const currentS = db.state.get('hook:ciFailure') ?? DEFAULT_CI_STATE;
                    db.state.set('hook:ciFailure', {
                        ...currentS,
                        error: errorMsg,
                        ciStatus: 'error'
                    }, 'ci-failure-error');
                    console.error('[OnCIFailure] Polling error:', errorMsg);
                }
            };
            // Initial check
            await checkCI();
            // Start polling
            pollIntervalRef.current = setInterval(checkCI, intervalMs);
        })();
    }, [db, executionEnabled, intervalMs, props.onFailure, props.provider]);
    useUnmount(() => {
        if (pollIntervalRef.current) {
            clearInterval(pollIntervalRef.current);
        }
    });
    return (_jsx("ci-failure-hook", { provider: props.provider, status: ciStatus, triggered: triggered, "run-id": currentFailure?.runId, "workflow-name": currentFailure?.workflowName, "failed-jobs": currentFailure?.failedJobs?.join(', '), "poll-interval": intervalMs, error: error, children: triggered ? props.children : null }));
}
//# sourceMappingURL=OnCIFailure.js.map