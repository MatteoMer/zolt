import { jsx as _jsx } from "react/jsx-runtime";
// PostCommit hook component - triggers children when a git commit is made
// Installs a git post-commit hook and polls db.state for triggers
import { useRef } from 'react';
import { useSmithers } from '../SmithersProvider.js';
import { useUnmount, useExecutionMount } from '../../reconciler/hooks.js';
import { useQueryValue } from '../../reactive-sqlite/index.js';
import { useExecutionContext } from '../ExecutionContext.js';
/**
 * Install the git post-commit hook
 */
async function installPostCommitHook() {
    const hookPath = '.git/hooks/post-commit';
    const hookContent = `#!/bin/bash
COMMIT_HASH=$(git rev-parse HEAD)
bunx smithers hook-trigger post-commit "$COMMIT_HASH"
`;
    await Bun.write(hookPath, hookContent);
    await Bun.$ `chmod +x ${hookPath}`;
}
/**
 * Check if a commit has smithers metadata in git notes
 */
async function hasSmithersMetadata(commitHash) {
    try {
        const result = await Bun.$ `git notes show ${commitHash} 2>/dev/null`.text();
        return result.toLowerCase().includes('smithers') || result.toLowerCase().includes('user prompt:');
    }
    catch {
        return false;
    }
}
const DEFAULT_STATE = {
    triggered: false,
    currentTrigger: null,
    hookInstalled: false,
    error: null,
    lastProcessedTimestamp: 0,
};
export function PostCommit(props) {
    const { db, reactiveDb, executionEnabled } = useSmithers();
    const execution = useExecutionContext();
    // Query state from db.state reactively
    const { data: stateJson } = useQueryValue(reactiveDb, "SELECT value FROM state WHERE key = 'hook:postCommit'");
    const state = (() => {
        if (!stateJson)
            return DEFAULT_STATE;
        try {
            return JSON.parse(stateJson);
        }
        catch {
            return DEFAULT_STATE;
        }
    })();
    const { triggered, currentTrigger, hookInstalled, error } = state;
    const pollIntervalRef = useRef(null);
    const taskIdRef = useRef(null);
    const shouldExecute = executionEnabled && execution.isActive;
    useExecutionMount(shouldExecute, () => {
        if (!db || !reactiveDb)
            return;
        // Initialize state if not present
        const currentState = db.state.get('hook:postCommit');
        if (!currentState) {
            db.state.set('hook:postCommit', DEFAULT_STATE, 'post-commit-init');
        }
        // Fire-and-forget async IIFE pattern
        ;
        (async () => {
            try {
                // Install the git hook
                await installPostCommitHook();
                const s = db.state.get('hook:postCommit') ?? DEFAULT_STATE;
                db.state.set('hook:postCommit', { ...s, hookInstalled: true }, 'post-commit-hook-installed');
                // Start polling for triggers
                pollIntervalRef.current = setInterval(async () => {
                    try {
                        const trigger = db.state.get('last_hook_trigger');
                        const currentS = db.state.get('hook:postCommit') ?? DEFAULT_STATE;
                        if (trigger && trigger.type === 'post-commit' && trigger.timestamp > currentS.lastProcessedTimestamp) {
                            // Check filter conditions
                            let shouldTrigger = true;
                            if (props.runOn === 'smithers-only') {
                                shouldTrigger = await hasSmithersMetadata(trigger.commitHash);
                            }
                            if (shouldTrigger) {
                                db.state.set('hook:postCommit', {
                                    ...currentS,
                                    triggered: true,
                                    currentTrigger: trigger,
                                    lastProcessedTimestamp: trigger.timestamp,
                                }, 'post-commit-triggered');
                                // Mark as processed in db
                                db.state.set('last_hook_trigger', {
                                    ...trigger,
                                    processed: true,
                                }, 'post-commit-hook');
                                // If running in background (async), register task
                                if (props.async) {
                                    taskIdRef.current = db.tasks.start('post-commit-hook');
                                    // Task will be completed when children finish
                                    // For now, we complete immediately as children handle their own task registration
                                    db.tasks.complete(taskIdRef.current);
                                }
                            }
                        }
                    }
                    catch (pollError) {
                        console.error('[PostCommit] Polling error:', pollError);
                    }
                }, 1000); // Poll every 1 second
            }
            catch (err) {
                const errorMsg = err instanceof Error ? err.message : String(err);
                const s = db.state.get('hook:postCommit') ?? DEFAULT_STATE;
                db.state.set('hook:postCommit', { ...s, error: errorMsg }, 'post-commit-error');
                console.error('[PostCommit] Failed to install hook:', errorMsg);
            }
        })();
    }, [db, reactiveDb, executionEnabled, props.async, props.runOn]);
    useUnmount(() => {
        if (pollIntervalRef.current) {
            clearInterval(pollIntervalRef.current);
        }
    });
    return (_jsx("post-commit-hook", { installed: hookInstalled, triggered: triggered, "commit-hash": currentTrigger?.commitHash, "run-on": props.runOn || 'all', async: props.async || false, error: error, children: triggered ? props.children : null }));
}
//# sourceMappingURL=PostCommit.js.map