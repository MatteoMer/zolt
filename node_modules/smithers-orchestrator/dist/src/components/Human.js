import { jsx as _jsx } from "react/jsx-runtime";
import { useRef } from 'react';
import { useSmithers } from './SmithersProvider.js';
import { useMount, useEffectOnValueChange } from '../reconciler/hooks.js';
import { useQueryOne } from '../reactive-sqlite/index.js';
/**
 * Human component - pauses execution for human interaction.
 *
 * When the execution loop encounters a Human node, it pauses
 * and waits for human approval/rejection before continuing.
 *
 * @example
 * ```tsx
 * <Human
 *   message="Approve deployment?"
 *   onApprove={() => setApproved(true)}
 *   onReject={() => setRejected(true)}
 * >
 *   About to deploy to production
 * </Human>
 * ```
 */
export function Human(props) {
    const { db } = useSmithers();
    // Use stable id for resumability (falls back to random if not provided)
    const humanId = props.id ?? crypto.randomUUID();
    const stateKey = `human:${humanId}`;
    const taskIdRef = useRef(null);
    const requestIdRef = useRef(null);
    useMount(() => {
        // Check for existing request (resumability)
        const existingRequestId = db.state.get(stateKey);
        if (existingRequestId) {
            requestIdRef.current = existingRequestId;
            // Don't start a new task if resuming
            return;
        }
        // Register blocking task
        taskIdRef.current = db.tasks.start('human_interaction', props.message ?? 'Human input required');
        // Create human interaction request
        requestIdRef.current = db.human.request('confirmation', props.message ?? 'Approve to continue');
        // Store request id for resumability
        db.state.set(stateKey, requestIdRef.current, 'human_request');
    });
    // Reactive subscription to the request
    const { data: request } = useQueryOne(db.db, requestIdRef.current
        ? `SELECT * FROM human_interactions WHERE id = ?`
        : `SELECT 1 WHERE 0`, requestIdRef.current ? [requestIdRef.current] : []);
    // Handle resolution
    useEffectOnValueChange(request?.status, () => {
        if (!request || request.status === 'pending')
            return;
        // Complete task to unblock orchestration
        if (taskIdRef.current) {
            db.tasks.complete(taskIdRef.current);
            taskIdRef.current = null;
        }
        // Fire callbacks
        if (request.status === 'approved') {
            props.onApprove?.();
        }
        else {
            props.onReject?.();
        }
    });
    return (_jsx("human", { message: props.message, children: props.children }));
}
//# sourceMappingURL=Human.js.map