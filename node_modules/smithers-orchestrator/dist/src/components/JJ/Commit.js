import { jsx as _jsx } from "react/jsx-runtime";
import { useRef, useReducer } from 'react';
import { useSmithers } from '../SmithersProvider.js';
import { jjCommit, addGitNotes, getJJDiffStats } from '../../utils/vcs.js';
import { useMountedState, useExecutionMount } from '../../reconciler/hooks.js';
import { useExecutionContext } from '../ExecutionContext.js';
/**
 * JJ Commit component - creates a JJ commit with optional auto-describe.
 *
 * React pattern: Uses useRef + forceUpdate for fire-and-forget VCS ops.
 * Registers with Ralph for task tracking.
 */
export function Commit(props) {
    const smithers = useSmithers();
    const execution = useExecutionContext();
    const [, forceUpdate] = useReducer((x) => x + 1, 0);
    const statusRef = useRef('pending');
    const commitHashRef = useRef(null);
    const changeIdRef = useRef(null);
    const errorRef = useRef(null);
    const taskIdRef = useRef(null);
    const isMounted = useMountedState();
    const shouldExecute = smithers.executionEnabled && execution.isActive;
    useExecutionMount(shouldExecute, () => {
        ;
        (async () => {
            taskIdRef.current = smithers.db.tasks.start('jj-commit');
            try {
                statusRef.current = 'running';
                forceUpdate();
                let message = props.message;
                if (props.autoDescribe && !message) {
                    const diffResult = await Bun.$ `jj diff`.text();
                    const lines = diffResult.split('\n').length;
                    message = `Auto-generated commit: ${lines} lines changed`;
                }
                if (!message) {
                    message = 'Commit by Smithers';
                }
                const result = await jjCommit(message);
                if (!isMounted())
                    return;
                commitHashRef.current = result.commitHash;
                changeIdRef.current = result.changeId;
                const stats = await getJJDiffStats();
                if (props.notes) {
                    await addGitNotes(props.notes);
                }
                await smithers.db.vcs.logCommit({
                    vcs_type: 'jj',
                    commit_hash: result.commitHash,
                    change_id: result.changeId,
                    message,
                    files_changed: stats.files,
                    insertions: stats.insertions,
                    deletions: stats.deletions,
                    ...(props.notes ? { smithers_metadata: { notes: props.notes } } : {}),
                });
                if (isMounted()) {
                    statusRef.current = 'complete';
                    forceUpdate();
                }
            }
            catch (err) {
                if (isMounted()) {
                    errorRef.current = err instanceof Error ? err : new Error(String(err));
                    statusRef.current = 'error';
                    forceUpdate();
                }
            }
            finally {
                if (taskIdRef.current) {
                    smithers.db.tasks.complete(taskIdRef.current);
                }
            }
        })();
    }, [props.autoDescribe, props.message, props.notes, smithers]);
    return (_jsx("jj-commit", { status: statusRef.current, "commit-hash": commitHashRef.current, "change-id": changeIdRef.current, error: errorRef.current?.message, message: props.message, "auto-describe": props.autoDescribe, children: props.children }));
}
//# sourceMappingURL=Commit.js.map