import { jsx as _jsx } from "react/jsx-runtime";
import { useRef, useReducer } from 'react';
import { useSmithers } from '../SmithersProvider.js';
import { getJJStatus } from '../../utils/vcs.js';
import { useMountedState, useExecutionMount } from '../../reconciler/hooks.js';
import { useExecutionContext } from '../ExecutionContext.js';
/**
 * JJ Status component - checks JJ working copy status.
 *
 * React pattern: Uses useRef + forceUpdate for fire-and-forget VCS ops.
 * Registers with Ralph for task tracking.
 */
export function Status(props) {
    const smithers = useSmithers();
    const execution = useExecutionContext();
    const [, forceUpdate] = useReducer((x) => x + 1, 0);
    const statusRef = useRef('pending');
    const isDirtyRef = useRef(null);
    const fileStatusRef = useRef(null);
    const errorRef = useRef(null);
    const taskIdRef = useRef(null);
    const isMounted = useMountedState();
    const shouldExecute = smithers.executionEnabled && execution.isActive;
    useExecutionMount(shouldExecute, () => {
        ;
        (async () => {
            taskIdRef.current = smithers.db.tasks.start('jj-status');
            try {
                statusRef.current = 'running';
                forceUpdate();
                const jjStatus = await getJJStatus();
                if (!isMounted())
                    return;
                fileStatusRef.current = jjStatus;
                const dirty = jjStatus.modified.length > 0 ||
                    jjStatus.added.length > 0 ||
                    jjStatus.deleted.length > 0;
                isDirtyRef.current = dirty;
                if (dirty) {
                    props.onDirty?.(jjStatus);
                }
                else {
                    props.onClean?.();
                }
                if (isMounted()) {
                    statusRef.current = 'complete';
                    forceUpdate();
                }
                await smithers.db.vcs.addReport({
                    type: 'progress',
                    title: 'JJ Status Check',
                    content: dirty
                        ? `Working copy is dirty: ${jjStatus.modified.length} modified, ${jjStatus.added.length} added, ${jjStatus.deleted.length} deleted`
                        : 'Working copy is clean',
                    data: {
                        isDirty: dirty,
                        ...jjStatus,
                    },
                });
            }
            catch (err) {
                if (isMounted()) {
                    errorRef.current = err instanceof Error ? err : new Error(String(err));
                    statusRef.current = 'error';
                    forceUpdate();
                }
            }
            finally {
                if (taskIdRef.current) {
                    smithers.db.tasks.complete(taskIdRef.current);
                }
            }
        })();
    }, [props.onClean, props.onDirty, smithers]);
    return (_jsx("jj-status", { status: statusRef.current, "is-dirty": isDirtyRef.current, modified: fileStatusRef.current?.modified?.join(','), added: fileStatusRef.current?.added?.join(','), deleted: fileStatusRef.current?.deleted?.join(','), error: errorRef.current?.message, children: props.children }));
}
//# sourceMappingURL=Status.js.map