import { jsx as _jsx } from "react/jsx-runtime";
// PhaseRegistry - Manages sequential phase execution via SQLite state
import { createContext, useContext, useRef, useCallback, useMemo } from 'react';
import { useSmithers } from './SmithersProvider.js';
import { useQueryValue } from '../reactive-sqlite/index.js';
import { useMount } from '../reconciler/hooks.js';
const PhaseRegistryContext = createContext(undefined);
export function usePhaseRegistry() {
    const ctx = useContext(PhaseRegistryContext);
    if (!ctx) {
        throw new Error('usePhaseRegistry must be used within PhaseRegistryProvider');
    }
    return ctx;
}
// Hook for phases to get their index during registration
export function usePhaseIndex(name) {
    const registry = usePhaseRegistry();
    const indexRef = useRef(null);
    if (indexRef.current === null) {
        indexRef.current = registry.registerPhase(name);
    }
    return indexRef.current;
}
export function PhaseRegistryProvider(props) {
    const { db, reactiveDb } = useSmithers();
    // Track registered phases in order (ref for synchronous registration)
    const phasesRef = useRef([]);
    // Read currentPhaseIndex from SQLite reactively
    const { data: dbPhaseIndex } = useQueryValue(reactiveDb, "SELECT CAST(value AS INTEGER) as idx FROM state WHERE key = 'currentPhaseIndex'");
    const currentPhaseIndex = dbPhaseIndex ?? 0;
    // Initialize currentPhaseIndex in DB only if not present (preserves resume)
    useMount(() => {
        const existing = db.state.get('currentPhaseIndex');
        if (existing === null || existing === undefined) {
            db.state.set('currentPhaseIndex', 0, 'phase_registry_init');
        }
    });
    // Register a phase and return its index
    const registerPhase = useCallback((name) => {
        const existingIndex = phasesRef.current.indexOf(name);
        if (existingIndex >= 0) {
            return existingIndex;
        }
        const index = phasesRef.current.length;
        phasesRef.current.push(name);
        return index;
    }, []);
    // Advance to next phase
    const advancePhase = useCallback(() => {
        const nextIndex = currentPhaseIndex + 1;
        if (nextIndex < phasesRef.current.length) {
            db.state.set('currentPhaseIndex', nextIndex, 'phase_advance');
        }
    }, [db, currentPhaseIndex]);
    // Check if phase is active
    const isPhaseActive = useCallback((index) => {
        return index === currentPhaseIndex;
    }, [currentPhaseIndex]);
    // Check if phase is completed
    const isPhaseCompleted = useCallback((index) => {
        return index < currentPhaseIndex;
    }, [currentPhaseIndex]);
    const value = useMemo(() => ({
        registerPhase,
        currentPhaseIndex,
        advancePhase,
        isPhaseActive,
        isPhaseCompleted,
        totalPhases: phasesRef.current.length,
    }), [registerPhase, currentPhaseIndex, advancePhase, isPhaseActive, isPhaseCompleted]);
    return (_jsx(PhaseRegistryContext.Provider, { value: value, children: props.children }));
}
//# sourceMappingURL=PhaseRegistry.js.map