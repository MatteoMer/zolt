import { type ReactNode } from 'react';
import type { SmithersDB } from '../db/index.js';
import type { ReactiveDatabase } from '../reactive-sqlite/index.js';
import type { SmithersMiddleware } from '../middleware/types.js';
/**
 * Create a promise that resolves when orchestration completes.
 * Returns a token that can be used to signal completion.
 * Called by createSmithersRoot before mounting.
 */
export declare function createOrchestrationPromise(): {
    promise: Promise<void>;
    token: string;
};
/**
 * Signal completion for a specific orchestration token.
 * Used by reconciler root.ts for direct control.
 */
export declare function signalOrchestrationCompleteByToken(token: string): void;
/**
 * Signal error for a specific orchestration token.
 * Used by reconciler root.ts for direct control.
 */
export declare function signalOrchestrationErrorByToken(token: string, err: Error): void;
/**
 * Hook to get the current orchestration token from context.
 * Returns null if not within a SmithersProvider.
 */
export declare function useOrchestrationToken(): string | null;
/**
 * Signal that orchestration is complete.
 * Use within a SmithersProvider context - reads token from context.
 * @deprecated Use signalOrchestrationCompleteByToken with an explicit token for concurrency safety.
 */
export declare function signalOrchestrationComplete(): void;
/**
 * Signal that orchestration failed.
 * @deprecated Use signalOrchestrationErrorByToken with an explicit token for concurrency safety.
 */
export declare function signalOrchestrationError(err: Error): void;
/**
 * Set the active orchestration token.
 * @deprecated No longer needed - tokens are managed via React context.
 */
export declare function setActiveOrchestrationToken(_token: string | null): void;
export interface GlobalStopCondition {
    type: 'total_tokens' | 'total_agents' | 'total_time' | 'report_severity' | 'ci_failure' | 'custom';
    value?: number | string;
    fn?: (context: OrchestrationContext) => boolean | Promise<boolean>;
    message?: string;
}
export interface OrchestrationContext {
    executionId: string;
    totalTokens: number;
    totalAgents: number;
    totalToolCalls: number;
    elapsedTimeMs: number;
}
export interface OrchestrationResult {
    executionId: string;
    status: 'completed' | 'stopped' | 'failed' | 'cancelled';
    totalAgents: number;
    totalToolCalls: number;
    totalTokens: number;
    durationMs: number;
}
export interface SmithersConfig {
    /**
     * Maximum number of iterations for Ralph loops
     */
    maxIterations?: number;
    /**
     * Default model to use for agents
     */
    defaultModel?: string;
    /**
     * Global timeout in milliseconds
     */
    globalTimeout?: number;
    /**
     * Enable verbose logging
     */
    verbose?: boolean;
    /**
     * Additional configuration for extensibility
     */
    extra?: Record<string, unknown>;
}
/**
 * Ralph context type for backwards compatibility
 * @deprecated Use db.tasks.start() and db.tasks.complete() instead
 */
export interface RalphContextType {
    /** @deprecated Use db.tasks.start() instead */
    registerTask: () => void;
    /** @deprecated Use db.tasks.complete() instead */
    completeTask: () => void;
    ralphCount: number;
    db: ReactiveDatabase | null;
}
export interface SmithersContextValue {
    /**
     * Database instance (SmithersDB wrapper)
     */
    db: SmithersDB;
    /**
     * Current execution ID
     */
    executionId: string;
    /**
     * Configuration
     */
    config: SmithersConfig;
    /**
     * Global middleware applied to all Claude executions.
     */
    middleware?: SmithersMiddleware[];
    /**
     * Request orchestration stop
     */
    requestStop: (reason: string) => void;
    /**
     * Request rebase operation
     */
    requestRebase: (reason: string) => void;
    /**
     * Check if stop has been requested
     */
    isStopRequested: () => boolean;
    /**
     * Check if rebase has been requested
     */
    isRebaseRequested: () => boolean;
    /**
     * @deprecated Use db.tasks.start() instead. This is a no-op.
     */
    registerTask: () => void;
    /**
     * @deprecated Use db.tasks.complete() instead. This is a no-op.
     */
    completeTask: () => void;
    /**
     * Current Ralph iteration count
     */
    ralphCount: number;
    /**
     * Raw ReactiveDatabase instance (for useQuery hooks)
     */
    reactiveDb: ReactiveDatabase;
    /**
     * Whether execution is enabled for this subtree
     */
    executionEnabled: boolean;
}
/**
 * Hook to access Smithers context
 *
 * Uses React's Context API, but falls back to module-level store
 * for universal renderer compatibility where context propagation
 * may not work as expected.
 */
export declare function useSmithers(): SmithersContextValue;
export interface ExecutionBoundaryProps {
    enabled: boolean;
    children: ReactNode;
}
export declare function ExecutionBoundary(props: ExecutionBoundaryProps): ReactNode;
export interface SmithersProviderProps {
    /**
     * Database instance
     */
    db: SmithersDB;
    /**
     * Execution ID from db.execution.start()
     */
    executionId: string;
    /**
     * Optional configuration
     */
    config?: SmithersConfig;
    /**
     * Optional tree serialization callback for frame capture.
     * Prefer passing root.toXML() from createSmithersRoot().
     */
    getTreeXML?: () => string | null;
    /**
     * Global middleware applied to all Claude executions.
     */
    middleware?: SmithersMiddleware[];
    /**
     * Maximum number of Ralph iterations (default: 100)
     */
    maxIterations?: number;
    /**
     * Callback fired on each Ralph iteration
     */
    onIteration?: (iteration: number) => void;
    /**
     * Callback fired when orchestration completes
     */
    onComplete?: () => void;
    /**
     * Global timeout in milliseconds
     */
    globalTimeout?: number;
    /**
     * Global stop conditions
     */
    stopConditions?: GlobalStopCondition[];
    /**
     * Create JJ snapshot before starting
     */
    snapshotBeforeStart?: boolean;
    /**
     * Callback when an error occurs
     */
    onError?: (error: Error) => void;
    /**
     * Callback when stop is requested
     */
    onStopRequested?: (reason: string) => void;
    /**
     * Cleanup on complete (close DB, etc.)
     */
    cleanupOnComplete?: boolean;
    /**
     * Explicitly stop the Ralph loop when true.
     * Use this to control orchestration flow declaratively.
     */
    stopped?: boolean;
    /**
     * Orchestration token for signaling completion.
     * Created by createOrchestrationPromise() in root.ts.
     * Required for concurrency-safe multi-root execution.
     */
    orchestrationToken?: string;
    /**
     * Children components
     */
    children: ReactNode;
}
/**
 * SmithersProvider - Unified root context provider
 *
 * Consolidates SmithersProvider, RalphContext, DatabaseProvider, and Orchestration into one.
 * Task tracking is fully database-backed via the tasks table.
 * Provides global timeouts, stop conditions, VCS snapshots, and cleanup.
 *
 * Usage:
 * ```tsx
 * const db = await createSmithersDB({ path: '.smithers/data' })
 * const executionId = await db.execution.start('My Orchestration', './main.tsx')
 *
 * <SmithersProvider
 *   db={db}
 *   executionId={executionId}
 *   maxIterations={10}
 *   globalTimeout={3600000}
 *   stopConditions={[
 *     { type: 'total_tokens', value: 500000, message: 'Token budget exceeded' }
 *   ]}
 *   snapshotBeforeStart
 * >
 *   <Claude>Do something</Claude>
 * </SmithersProvider>
 * ```
 */
export declare function SmithersProvider(props: SmithersProviderProps): ReactNode;
/**
 * Hook for backwards-compatible Ralph context access
 * Returns the same interface as the original RalphContext
 * @deprecated Use useSmithers() and db.tasks instead
 */
export declare function useRalph(): RalphContextType;
//# sourceMappingURL=SmithersProvider.d.ts.map