import { jsx as _jsx } from "react/jsx-runtime";
// SmithersProvider - Unified context provider for Smithers orchestration
// Consolidates SmithersProvider, RalphContext, and DatabaseProvider into one
// Gives all child components access to database, executionId, Ralph loop, and global controls
import { createContext, useContext, useMemo, useRef } from 'react';
import { DatabaseProvider } from '../reactive-sqlite/hooks/context.js';
import { useQueryValue } from '../reactive-sqlite/index.js';
import { PhaseRegistryProvider } from './PhaseRegistry.js';
import { useMount, useUnmount, useEffectOnValueChange } from '../reconciler/hooks.js';
import { useCaptureRenderFrame } from '../hooks/useCaptureRenderFrame.js';
import { jjSnapshot } from '../utils/vcs.js';
// Tokenized map for per-root orchestration - concurrency-safe
const orchestrationControllers = new Map();
// Cleanup stale entries after 1 hour (prevents memory leak if orchestration errors without cleanup)
const ORCHESTRATION_CLEANUP_TIMEOUT_MS = 3600000;
// Track cleanup timeouts for each token
const cleanupTimeouts = new Map();
function scheduleOrchestrationCleanup(token) {
    const timeoutId = setTimeout(() => {
        orchestrationControllers.delete(token);
        cleanupTimeouts.delete(token);
    }, ORCHESTRATION_CLEANUP_TIMEOUT_MS);
    cleanupTimeouts.set(token, timeoutId);
}
function cancelOrchestrationCleanup(token) {
    const timeoutId = cleanupTimeouts.get(token);
    if (timeoutId) {
        clearTimeout(timeoutId);
        cleanupTimeouts.delete(token);
    }
}
// Context for per-provider orchestration token (replaces global _activeOrchestrationToken)
const OrchestrationTokenContext = createContext(null);
/**
 * Create a promise that resolves when orchestration completes.
 * Returns a token that can be used to signal completion.
 * Called by createSmithersRoot before mounting.
 */
export function createOrchestrationPromise() {
    const token = crypto.randomUUID();
    const promise = new Promise((resolve, reject) => {
        orchestrationControllers.set(token, { resolve, reject });
        scheduleOrchestrationCleanup(token);
    });
    return { promise, token };
}
/**
 * Signal completion for a specific orchestration token.
 * Used by reconciler root.ts for direct control.
 */
export function signalOrchestrationCompleteByToken(token) {
    cancelOrchestrationCleanup(token);
    const controller = orchestrationControllers.get(token);
    if (controller) {
        controller.resolve();
        orchestrationControllers.delete(token);
    }
}
/**
 * Signal error for a specific orchestration token.
 * Used by reconciler root.ts for direct control.
 */
export function signalOrchestrationErrorByToken(token, err) {
    cancelOrchestrationCleanup(token);
    const controller = orchestrationControllers.get(token);
    if (controller) {
        controller.reject(err);
        orchestrationControllers.delete(token);
    }
}
/**
 * Hook to get the current orchestration token from context.
 * Returns null if not within a SmithersProvider.
 */
export function useOrchestrationToken() {
    return useContext(OrchestrationTokenContext);
}
/**
 * Signal that orchestration is complete.
 * Use within a SmithersProvider context - reads token from context.
 * @deprecated Use signalOrchestrationCompleteByToken with an explicit token for concurrency safety.
 */
export function signalOrchestrationComplete() {
    console.warn('[SmithersProvider] signalOrchestrationComplete() without token is deprecated. Use signalOrchestrationCompleteByToken(token) for concurrency safety.');
}
/**
 * Signal that orchestration failed.
 * @deprecated Use signalOrchestrationErrorByToken with an explicit token for concurrency safety.
 */
export function signalOrchestrationError(err) {
    console.warn('[SmithersProvider] signalOrchestrationError() without token is deprecated. Use signalOrchestrationErrorByToken(token, err) for concurrency safety.');
    void err;
}
/**
 * Set the active orchestration token.
 * @deprecated No longer needed - tokens are managed via React context.
 */
export function setActiveOrchestrationToken(_token) {
    // No-op for backwards compatibility - token is now stored in React context
}
// ============================================================================
// CONTEXT
// ============================================================================
const SmithersContext = createContext(undefined);
/**
 * Hook to access Smithers context
 *
 * Uses React's Context API, but falls back to module-level store
 * for universal renderer compatibility where context propagation
 * may not work as expected.
 */
export function useSmithers() {
    // Try React's Context first
    const ctx = useContext(SmithersContext);
    if (ctx) {
        return ctx;
    }
    throw new Error('useSmithers must be used within SmithersProvider');
}
export function ExecutionBoundary(props) {
    const parent = useSmithers();
    const scopedValue = useMemo(() => ({
        ...parent,
        executionEnabled: parent.executionEnabled && props.enabled,
    }), [parent, props.enabled]);
    return (_jsx(SmithersContext.Provider, { value: scopedValue, children: props.children }));
}
/**
 * SmithersProvider - Unified root context provider
 *
 * Consolidates SmithersProvider, RalphContext, DatabaseProvider, and Orchestration into one.
 * Task tracking is fully database-backed via the tasks table.
 * Provides global timeouts, stop conditions, VCS snapshots, and cleanup.
 *
 * Usage:
 * ```tsx
 * const db = await createSmithersDB({ path: '.smithers/data' })
 * const executionId = await db.execution.start('My Orchestration', './main.tsx')
 *
 * <SmithersProvider
 *   db={db}
 *   executionId={executionId}
 *   maxIterations={10}
 *   globalTimeout={3600000}
 *   stopConditions={[
 *     { type: 'total_tokens', value: 500000, message: 'Token budget exceeded' }
 *   ]}
 *   snapshotBeforeStart
 * >
 *   <Claude>Do something</Claude>
 * </SmithersProvider>
 * ```
 */
export function SmithersProvider(props) {
    const maxIterations = props.maxIterations ?? props.config?.maxIterations ?? 100;
    const reactiveDb = props.db.db;
    // Orchestration refs for timers and start time
    const startTimeRef = useRef(Date.now());
    const timeoutIdRef = useRef(null);
    const checkIntervalIdRef = useRef(null);
    // Read stop/rebase signals from database reactively
    const { data: stopRequested } = useQueryValue(reactiveDb, "SELECT CASE WHEN value IS NOT NULL THEN 1 ELSE 0 END as requested FROM state WHERE key = 'stop_requested'");
    const { data: rebaseRequested } = useQueryValue(reactiveDb, "SELECT CASE WHEN value IS NOT NULL THEN 1 ELSE 0 END as requested FROM state WHERE key = 'rebase_requested'");
    // Read ralphCount from database reactively
    const { data: dbRalphCount } = useQueryValue(reactiveDb, "SELECT CAST(value AS INTEGER) as count FROM state WHERE key = 'ralphCount'");
    // Use DB value if available, otherwise default to 0
    const ralphCount = dbRalphCount ?? 0;
    // Read running task count from database reactively
    const { data: runningTaskCount } = useQueryValue(reactiveDb, `SELECT COUNT(*) as count FROM tasks WHERE execution_id = ? AND iteration = ? AND status = 'running'`, [props.executionId, ralphCount]);
    // Read total task count for this iteration (to know if tasks have started)
    const { data: totalTaskCount } = useQueryValue(reactiveDb, `SELECT COUNT(*) as count FROM tasks WHERE execution_id = ? AND iteration = ?`, [props.executionId, ralphCount]);
    // Derive state from DB queries
    const pendingTasks = runningTaskCount ?? 0;
    const hasStartedTasks = (totalTaskCount ?? 0) > 0;
    // Track if we've already completed to avoid double-completion
    const hasCompletedRef = useRef(false);
    // Track stable state for debouncing completion checks
    const stableCountRef = useRef(0);
    const completionCheckTimeoutRef = useRef(null);
    // Get orchestration token from props for signaling completion
    const orchestrationToken = props.orchestrationToken ?? null;
    // Helper to signal completion using the token
    const signalComplete = useMemo(() => () => {
        if (orchestrationToken) {
            signalOrchestrationCompleteByToken(orchestrationToken);
        }
    }, [orchestrationToken]);
    // Initialize ralphCount in DB if needed
    useMount(() => {
        if (dbRalphCount == null && !reactiveDb.isClosed) {
            reactiveDb.run("INSERT OR IGNORE INTO state (key, value, updated_at) VALUES ('ralphCount', '0', datetime('now'))");
        }
    });
    // Orchestration setup (timeout, snapshots, stop conditions)
    useMount(() => {
        const startTime = startTimeRef.current;
        (async () => {
            try {
                // Create snapshot if requested
                if (props.snapshotBeforeStart) {
                    try {
                        const { changeId, description } = await jjSnapshot('Before orchestration start');
                        await props.db.vcs.logSnapshot({
                            change_id: changeId,
                            description,
                        });
                        console.log(`[SmithersProvider] Created initial snapshot: ${changeId}`);
                    }
                    catch (error) {
                        // JJ might not be available, that's okay
                        console.warn('[SmithersProvider] Could not create JJ snapshot:', error);
                    }
                }
                // Set up global timeout
                if (props.globalTimeout) {
                    timeoutIdRef.current = setTimeout(() => {
                        const currentStopRequested = props.db.state.get('stop_requested');
                        if (!currentStopRequested) {
                            const message = `Global timeout of ${props.globalTimeout}ms exceeded`;
                            props.db.state.set('stop_requested', {
                                reason: message,
                                timestamp: Date.now(),
                                executionId: props.executionId,
                            });
                            props.onStopRequested?.(message);
                        }
                    }, props.globalTimeout);
                }
                // Set up stop condition checking
                if (props.stopConditions && props.stopConditions.length > 0) {
                    checkIntervalIdRef.current = setInterval(async () => {
                        const currentStopRequested = props.db.state.get('stop_requested');
                        if (currentStopRequested) {
                            if (checkIntervalIdRef.current)
                                clearInterval(checkIntervalIdRef.current);
                            return;
                        }
                        const execution = await props.db.execution.current();
                        if (!execution)
                            return;
                        const context = {
                            executionId: props.executionId,
                            totalTokens: execution.total_tokens_used,
                            totalAgents: execution.total_agents,
                            totalToolCalls: execution.total_tool_calls,
                            elapsedTimeMs: Date.now() - startTime,
                        };
                        for (const condition of props.stopConditions) {
                            let shouldStop = false;
                            let message = condition.message ?? 'Stop condition met';
                            switch (condition.type) {
                                case 'total_tokens':
                                    if (typeof condition.value === 'number') {
                                        shouldStop = context.totalTokens >= condition.value;
                                        message = message || `Token limit ${condition.value} exceeded`;
                                    }
                                    break;
                                case 'total_agents':
                                    if (typeof condition.value === 'number') {
                                        shouldStop = context.totalAgents >= condition.value;
                                        message = message || `Agent limit ${condition.value} exceeded`;
                                    }
                                    break;
                                case 'total_time':
                                    if (typeof condition.value === 'number') {
                                        shouldStop = context.elapsedTimeMs >= condition.value;
                                        message = message || `Time limit ${condition.value}ms exceeded`;
                                    }
                                    break;
                                case 'report_severity':
                                    const criticalReports = await props.db.vcs.getCriticalReports();
                                    shouldStop = criticalReports.length > 0;
                                    message = message || `Critical report(s) found: ${criticalReports.length}`;
                                    break;
                                case 'ci_failure':
                                    const ciFailure = await props.db.state.get('last_ci_failure');
                                    shouldStop = ciFailure !== null;
                                    message = message || `CI failure detected: ${ciFailure?.message ?? 'unknown'}`;
                                    break;
                                case 'custom':
                                    if (condition.fn) {
                                        shouldStop = await condition.fn(context);
                                    }
                                    break;
                            }
                            if (shouldStop) {
                                console.log(`[SmithersProvider] Stop condition met: ${message}`);
                                props.db.state.set('stop_requested', {
                                    reason: message,
                                    timestamp: Date.now(),
                                    executionId: props.executionId,
                                });
                                props.onStopRequested?.(message);
                                if (checkIntervalIdRef.current)
                                    clearInterval(checkIntervalIdRef.current);
                                break;
                            }
                        }
                    }, 1000); // Check every second
                }
            }
            catch (error) {
                console.error('[SmithersProvider] Setup error:', error);
                props.onError?.(error);
            }
        })();
    });
    // Increment ralphCount in DB
    const incrementRalphCount = useMemo(() => () => {
        if (reactiveDb.isClosed)
            return ralphCount; // Guard against closed DB
        const nextCount = ralphCount + 1;
        reactiveDb.run("UPDATE state SET value = ?, updated_at = datetime('now') WHERE key = 'ralphCount'", [String(nextCount)]);
        return nextCount;
    }, [reactiveDb, ralphCount]);
    // Deprecated no-op functions for backwards compatibility
    const registerTask = useMemo(() => () => {
        console.warn('[SmithersProvider] registerTask is deprecated. Use db.tasks.start() instead.');
    }, []);
    const completeTask = useMemo(() => () => {
        console.warn('[SmithersProvider] completeTask is deprecated. Use db.tasks.complete() instead.');
    }, []);
    // Capture render frame on each Ralph iteration
    useCaptureRenderFrame(props.db, ralphCount, props.getTreeXML);
    // React to task count changes instead of polling
    useEffectOnValueChange(pendingTasks, () => {
        // Clear any pending completion check
        if (completionCheckTimeoutRef.current) {
            clearTimeout(completionCheckTimeoutRef.current);
            completionCheckTimeoutRef.current = null;
        }
        // Check if explicitly stopped via prop
        if (props.stopped && !hasCompletedRef.current) {
            hasCompletedRef.current = true;
            signalComplete();
            props.onComplete?.();
            return;
        }
        // If tasks are running, reset stable counter
        if (pendingTasks > 0) {
            stableCountRef.current = 0;
            return;
        }
        // If no tasks have ever started, wait a bit then complete
        if (!hasStartedTasks) {
            stableCountRef.current++;
            // Debounce - wait 500ms before declaring no work
            completionCheckTimeoutRef.current = setTimeout(() => {
                if (!hasCompletedRef.current && stableCountRef.current > 0) {
                    hasCompletedRef.current = true;
                    signalComplete();
                    props.onComplete?.();
                }
            }, 500);
            return;
        }
        // Tasks have completed - debounce before advancing
        stableCountRef.current++;
        completionCheckTimeoutRef.current = setTimeout(() => {
            if (reactiveDb.isClosed)
                return;
            // Check if stop was requested
            if (stopRequested && !hasCompletedRef.current) {
                hasCompletedRef.current = true;
                signalComplete();
                props.onComplete?.();
                return;
            }
            // Check max iterations
            if (ralphCount >= maxIterations - 1) {
                if (!hasCompletedRef.current) {
                    hasCompletedRef.current = true;
                    signalComplete();
                    props.onComplete?.();
                }
                return;
            }
            // Trigger next iteration
            const nextIteration = incrementRalphCount();
            stableCountRef.current = 0;
            props.onIteration?.(nextIteration);
        }, 100); // 100ms debounce
        // Cleanup timeout on effect re-run
        return () => {
            if (completionCheckTimeoutRef.current) {
                clearTimeout(completionCheckTimeoutRef.current);
                completionCheckTimeoutRef.current = null;
            }
        };
    }, [hasStartedTasks, ralphCount, maxIterations, props, incrementRalphCount, stopRequested, reactiveDb, signalComplete]);
    // Cleanup on unmount
    useUnmount(() => {
        if (completionCheckTimeoutRef.current) {
            clearTimeout(completionCheckTimeoutRef.current);
        }
    });
    const value = useMemo(() => ({
        db: props.db,
        executionId: props.executionId,
        config: props.config ?? {},
        ...(props.middleware !== undefined ? { middleware: props.middleware } : {}),
        requestStop: (reason) => {
            props.db.state.set('stop_requested', {
                reason,
                timestamp: Date.now(),
                executionId: props.executionId,
            });
            console.log(`[Smithers] Stop requested: ${reason}`);
        },
        requestRebase: (reason) => {
            props.db.state.set('rebase_requested', {
                reason,
                timestamp: Date.now(),
                executionId: props.executionId,
            });
            console.log(`[Smithers] Rebase requested: ${reason}`);
        },
        isStopRequested: () => !!stopRequested,
        isRebaseRequested: () => !!rebaseRequested,
        // Ralph fields (registerTask/completeTask are deprecated no-ops)
        registerTask,
        completeTask,
        ralphCount,
        reactiveDb,
        executionEnabled: true,
    }), [props.db, props.executionId, props.config, props.middleware, stopRequested, rebaseRequested, registerTask, completeTask, ralphCount, reactiveDb]);
    // Cleanup orchestration on unmount
    useUnmount(() => {
        // Clear timers
        if (timeoutIdRef.current)
            clearTimeout(timeoutIdRef.current);
        if (checkIntervalIdRef.current)
            clearInterval(checkIntervalIdRef.current);
        (async () => {
            try {
                const execution = await props.db.execution.current();
                if (execution) {
                    props.onComplete?.();
                }
                // Cleanup if requested
                if (props.cleanupOnComplete) {
                    await props.db.close();
                }
            }
            catch (error) {
                console.error('[SmithersProvider] Cleanup error:', error);
                props.onError?.(error);
            }
        })().catch((err) => {
            console.error('[SmithersProvider] Unexpected cleanup error:', err);
        });
    });
    return (_jsx(OrchestrationTokenContext.Provider, { value: orchestrationToken, children: _jsx(SmithersContext.Provider, { value: value, children: _jsx(DatabaseProvider, { db: reactiveDb, children: _jsx(PhaseRegistryProvider, { children: props.children }) }) }) }));
}
/**
 * Hook for backwards-compatible Ralph context access
 * Returns the same interface as the original RalphContext
 * @deprecated Use useSmithers() and db.tasks instead
 */
export function useRalph() {
    const ctx = useSmithers();
    return {
        registerTask: ctx.registerTask,
        completeTask: ctx.completeTask,
        ralphCount: ctx.ralphCount,
        db: ctx.reactiveDb,
    };
}
//# sourceMappingURL=SmithersProvider.js.map