// Agent tracking module for Smithers DB
import { uuid, now, parseJson } from './utils.js';
const mapAgent = (row) => {
    if (!row)
        return null;
    const agent = {
        id: row.id,
        execution_id: row.execution_id,
        phase_id: row.phase_id ?? undefined,
        model: row.model,
        system_prompt: row.system_prompt ?? undefined,
        prompt: row.prompt,
        status: row.status,
        result: row.result ?? undefined,
        result_structured: row.result_structured ? parseJson(row.result_structured, undefined) : undefined,
        log_path: row.log_path ?? undefined,
        error: row.error ?? undefined,
        started_at: row.started_at ? new Date(row.started_at) : undefined,
        completed_at: row.completed_at ? new Date(row.completed_at) : undefined,
        created_at: new Date(row.created_at),
        duration_ms: row.duration_ms ?? undefined,
        tokens_input: row.tokens_input ?? undefined,
        tokens_output: row.tokens_output ?? undefined,
        tool_calls_count: row.tool_calls_count,
    };
    if (row.stream_summary) {
        const parsed = parseJson(row.stream_summary, null);
        if (parsed) {
            agent.stream_summary = parsed;
        }
    }
    return agent;
};
export function createAgentsModule(ctx) {
    const { rdb, getCurrentExecutionId, getCurrentPhaseId, getCurrentAgentId, setCurrentAgentId } = ctx;
    const agents = {
        start: (prompt, model = 'sonnet', systemPrompt, logPath) => {
            if (rdb.isClosed) {
                return uuid();
            }
            const currentExecutionId = getCurrentExecutionId();
            const currentPhaseId = getCurrentPhaseId();
            if (!currentExecutionId)
                throw new Error('No active execution');
            const id = uuid();
            const timestamp = now();
            rdb.transaction(() => {
                rdb.run(`INSERT INTO agents (id, execution_id, phase_id, model, system_prompt, prompt, status, started_at, created_at, log_path)
           VALUES (?, ?, ?, ?, ?, ?, 'running', ?, ?, ?)`, [id, currentExecutionId, currentPhaseId, model, systemPrompt ?? null, prompt, timestamp, timestamp, logPath ?? null]);
                rdb.run('UPDATE executions SET total_agents = total_agents + 1 WHERE id = ?', [currentExecutionId]);
            });
            setCurrentAgentId(id);
            return id;
        },
        complete: (id, result, structuredResult, tokens) => {
            if (rdb.isClosed)
                return;
            const timestamp = now();
            rdb.transaction(() => {
                const startRow = rdb.queryOne('SELECT started_at, execution_id FROM agents WHERE id = ?', [id]);
                const durationMs = startRow ? Date.now() - new Date(startRow.started_at).getTime() : null;
                rdb.run(`UPDATE agents SET status = 'completed', result = ?, result_structured = ?, tokens_input = ?, tokens_output = ?, completed_at = ?, duration_ms = ? WHERE id = ?`, [result, structuredResult ? JSON.stringify(structuredResult) : null, tokens?.input ?? null, tokens?.output ?? null, timestamp, durationMs, id]);
                if (tokens && startRow) {
                    rdb.run('UPDATE executions SET total_tokens_used = total_tokens_used + ? WHERE id = ?', [(tokens.input ?? 0) + (tokens.output ?? 0), startRow.execution_id]);
                }
            });
            if (getCurrentAgentId() === id)
                setCurrentAgentId(null);
        },
        fail: (id, error) => {
            if (rdb.isClosed)
                return;
            rdb.run(`UPDATE agents SET status = 'failed', error = ?, completed_at = ? WHERE id = ?`, [error, now(), id]);
            if (getCurrentAgentId() === id)
                setCurrentAgentId(null);
        },
        setStreamSummary: (id, summary) => {
            if (rdb.isClosed) {
                return;
            }
            rdb.run(`UPDATE agents SET stream_summary = ? WHERE id = ?`, [JSON.stringify(summary), id]);
        },
        recordStreamEvent: (agentId, part) => {
            if (rdb.isClosed) {
                return;
            }
            const eventId = "id" in part ? part.id :
                "toolCallId" in part ? part.toolCallId :
                    undefined;
            const toolName = "toolName" in part ? part.toolName :
                undefined;
            rdb.run(`INSERT INTO agent_stream_events (id, agent_id, event_type, event_id, tool_name, content, timestamp, created_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`, [
                uuid(),
                agentId,
                part.type,
                eventId ?? null,
                toolName ?? null,
                JSON.stringify(part),
                Date.now(),
                now(),
            ]);
        },
        getStreamEvents: (agentId, options) => {
            if (rdb.isClosed) {
                return [];
            }
            const types = options?.types ?? [];
            const limit = options?.limit ?? 1000;
            if (types.length > 0) {
                const placeholders = types.map(() => '?').join(', ');
                return rdb.query(`SELECT * FROM agent_stream_events WHERE agent_id = ? AND event_type IN (${placeholders}) ORDER BY timestamp DESC LIMIT ?`, [agentId, ...types, limit]);
            }
            return rdb.query(`SELECT * FROM agent_stream_events WHERE agent_id = ? ORDER BY timestamp DESC LIMIT ?`, [agentId, limit]);
        },
        current: () => {
            if (rdb.isClosed)
                return null;
            const currentAgentId = getCurrentAgentId();
            if (!currentAgentId)
                return null;
            return mapAgent(rdb.queryOne('SELECT * FROM agents WHERE id = ?', [currentAgentId]));
        },
        list: (executionId) => {
            if (rdb.isClosed)
                return [];
            return rdb.query('SELECT * FROM agents WHERE execution_id = ? ORDER BY created_at', [executionId])
                .map(mapAgent)
                .filter((a) => a !== null);
        },
    };
    return agents;
}
//# sourceMappingURL=agents.js.map