// Build state coordination module for broken build orchestration
import { now } from './utils.js';
const DEFAULT_STATE = {
    id: 1,
    status: 'passing',
    fixer_agent_id: null,
    broken_since: null,
    last_check: null,
};
const DEFAULT_WAIT_MS = 5 * 60 * 1000;
const DEFAULT_STALE_MS = 15 * 60 * 1000;
export function createBuildStateModule(ctx) {
    const { rdb } = ctx;
    const ensureRow = () => {
        if (rdb.isClosed)
            return;
        rdb.run(`INSERT INTO build_state (id, status, last_check)
       VALUES (1, 'passing', ?)
       ON CONFLICT(id) DO NOTHING`, [now()]);
    };
    const get = () => {
        if (rdb.isClosed)
            return { ...DEFAULT_STATE };
        ensureRow();
        const row = rdb.queryOne('SELECT * FROM build_state WHERE id = 1');
        return row ?? { ...DEFAULT_STATE };
    };
    const updateState = (next) => {
        if (rdb.isClosed)
            return { ...DEFAULT_STATE, ...next };
        ensureRow();
        const current = get();
        const merged = { ...current, ...next };
        rdb.run(`UPDATE build_state
       SET status = ?, fixer_agent_id = ?, broken_since = ?, last_check = ?
       WHERE id = 1`, [merged.status, merged.fixer_agent_id, merged.broken_since, merged.last_check]);
        return get();
    };
    const cleanup = (staleMs = DEFAULT_STALE_MS) => {
        if (rdb.isClosed)
            return { ...DEFAULT_STATE };
        ensureRow();
        const current = get();
        if (current.status !== 'fixing' || !current.broken_since) {
            return current;
        }
        const brokenSinceMs = Date.parse(current.broken_since);
        if (!Number.isFinite(brokenSinceMs)) {
            return current;
        }
        if (Date.now() - brokenSinceMs < staleMs) {
            return current;
        }
        return updateState({
            status: 'broken',
            fixer_agent_id: null,
            last_check: now(),
        });
    };
    const handleBrokenBuild = (agentId, options) => {
        if (rdb.isClosed) {
            return { shouldFix: false, waitMs: options?.waitMs ?? DEFAULT_WAIT_MS, state: { ...DEFAULT_STATE } };
        }
        const waitMs = options?.waitMs ?? DEFAULT_WAIT_MS;
        const staleMs = options?.staleMs ?? DEFAULT_STALE_MS;
        const timestamp = now();
        return rdb.transaction(() => {
            ensureRow();
            const cleaned = cleanup(staleMs);
            const state = cleaned;
            if (state.status === 'fixing') {
                const isFixer = state.fixer_agent_id === agentId;
                const next = updateState({ last_check: timestamp });
                return { shouldFix: isFixer, waitMs, state: next };
            }
            if (state.status === 'passing') {
                const result = rdb.run(`UPDATE build_state
           SET status = 'fixing', fixer_agent_id = ?, broken_since = ?, last_check = ?
           WHERE id = 1 AND status = 'passing'`, [agentId, timestamp, timestamp]);
                const next = get();
                return { shouldFix: result.changes > 0, waitMs, state: next };
            }
            const brokenSince = state.broken_since ?? timestamp;
            const result = rdb.run(`UPDATE build_state
         SET status = 'fixing', fixer_agent_id = ?, broken_since = ?, last_check = ?
         WHERE id = 1 AND status = 'broken'`, [agentId, brokenSince, timestamp]);
            const next = get();
            return { shouldFix: result.changes > 0, waitMs, state: next };
        });
    };
    const markFixed = () => {
        if (rdb.isClosed)
            return { ...DEFAULT_STATE };
        return updateState({
            status: 'passing',
            fixer_agent_id: null,
            broken_since: null,
            last_check: now(),
        });
    };
    return {
        get,
        handleBrokenBuild,
        markFixed,
        cleanup,
    };
}
//# sourceMappingURL=build-state.js.map