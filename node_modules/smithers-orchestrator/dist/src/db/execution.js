// Execution tracking module for Smithers DB
import { uuid, now, parseJson } from './utils.js';
const mapExecution = (row) => {
    if (!row)
        return null;
    return {
        id: row.id,
        name: row.name ?? undefined,
        file_path: row.file_path,
        status: row.status,
        config: parseJson(row.config, {}),
        result: row.result ? parseJson(row.result, undefined) : undefined,
        error: row.error ?? undefined,
        started_at: row.started_at ? new Date(row.started_at) : undefined,
        completed_at: row.completed_at ? new Date(row.completed_at) : undefined,
        created_at: new Date(row.created_at),
        total_iterations: row.total_iterations,
        total_agents: row.total_agents,
        total_tool_calls: row.total_tool_calls,
        total_tokens_used: row.total_tokens_used,
    };
};
export function createExecutionModule(ctx) {
    const { rdb, getCurrentExecutionId, setCurrentExecutionId } = ctx;
    const execution = {
        start: (name, filePath, config) => {
            if (rdb.isClosed)
                return uuid();
            const id = uuid();
            rdb.run(`INSERT INTO executions (id, name, file_path, status, config, started_at, created_at)
         VALUES (?, ?, ?, 'running', ?, ?, ?)`, [id, name, filePath, JSON.stringify(config ?? {}), now(), now()]);
            setCurrentExecutionId(id);
            return id;
        },
        complete: (id, result) => {
            if (rdb.isClosed)
                return;
            rdb.run(`UPDATE executions SET status = 'completed', result = ?, completed_at = ? WHERE id = ?`, [result ? JSON.stringify(result) : null, now(), id]);
            if (getCurrentExecutionId() === id)
                setCurrentExecutionId(null);
        },
        fail: (id, error) => {
            if (rdb.isClosed)
                return;
            rdb.run(`UPDATE executions SET status = 'failed', error = ?, completed_at = ? WHERE id = ?`, [error, now(), id]);
            if (getCurrentExecutionId() === id)
                setCurrentExecutionId(null);
        },
        cancel: (id) => {
            if (rdb.isClosed)
                return;
            rdb.run(`UPDATE executions SET status = 'cancelled', completed_at = ? WHERE id = ?`, [now(), id]);
            if (getCurrentExecutionId() === id)
                setCurrentExecutionId(null);
        },
        current: () => {
            if (rdb.isClosed)
                return null;
            const currentId = getCurrentExecutionId();
            if (!currentId)
                return null;
            return mapExecution(rdb.queryOne('SELECT * FROM executions WHERE id = ?', [currentId]));
        },
        get: (id) => {
            if (rdb.isClosed)
                return null;
            return mapExecution(rdb.queryOne('SELECT * FROM executions WHERE id = ?', [id]));
        },
        list: (limit = 20) => {
            if (rdb.isClosed)
                return [];
            return rdb.query('SELECT * FROM executions ORDER BY created_at DESC LIMIT ?', [limit])
                .map(mapExecution)
                .filter((e) => e !== null);
        },
        findIncomplete: () => {
            if (rdb.isClosed)
                return null;
            return mapExecution(rdb.queryOne("SELECT * FROM executions WHERE status IN ('pending', 'running') ORDER BY created_at DESC LIMIT 1"));
        },
    };
    return execution;
}
//# sourceMappingURL=execution.js.map