// Human interaction module
// Handles requests for human input/confirmation
import { uuid, now } from './utils.js';
export function parseHumanInteraction(row) {
    return {
        ...row,
        options: row.options ? JSON.parse(row.options) : null,
        response: row.response ? JSON.parse(row.response) : null,
        session_config: row.session_config ? JSON.parse(row.session_config) : null,
    };
}
export function createHumanModule(ctx) {
    const { rdb, getCurrentExecutionId } = ctx;
    return {
        request: (type, prompt, options = []) => {
            if (rdb.isClosed)
                return uuid();
            const executionId = getCurrentExecutionId();
            if (!executionId)
                throw new Error('No active execution');
            const id = uuid();
            rdb.run(`INSERT INTO human_interactions (id, execution_id, type, prompt, options, status, created_at)
         VALUES (?, ?, ?, ?, ?, 'pending', ?)`, [id, executionId, type, prompt, JSON.stringify(options), now()]);
            return id;
        },
        requestInteractive: (prompt, config) => {
            if (rdb.isClosed)
                return uuid();
            const executionId = getCurrentExecutionId();
            if (!executionId)
                throw new Error('No active execution');
            const id = uuid();
            rdb.run(`INSERT INTO human_interactions
         (id, execution_id, type, prompt, options, status, session_config, created_at)
         VALUES (?, ?, 'interactive_session', ?, ?, 'pending', ?, ?)`, [id, executionId, prompt, null, JSON.stringify(config), now()]);
            return id;
        },
        resolve: (id, status, response = null) => {
            if (rdb.isClosed)
                return;
            rdb.run(`UPDATE human_interactions
         SET status = ?, response = ?, resolved_at = ?
         WHERE id = ?`, [status, JSON.stringify(response), now(), id]);
        },
        completeInteractive: (id, outcome, response, options) => {
            if (rdb.isClosed)
                return;
            rdb.run(`UPDATE human_interactions
         SET status = ?, response = ?, session_transcript = ?,
             session_duration = ?, error = ?, resolved_at = ?
         WHERE id = ?`, [
                outcome,
                JSON.stringify(response),
                options?.transcript ?? null,
                options?.duration ?? null,
                options?.error ?? null,
                now(),
                id,
            ]);
        },
        cancelInteractive: (id) => {
            if (rdb.isClosed)
                return;
            rdb.run(`UPDATE human_interactions
         SET status = 'cancelled', resolved_at = ?
         WHERE id = ? AND status = 'pending'`, [now(), id]);
        },
        get: (id) => {
            if (rdb.isClosed)
                return null;
            const row = rdb.queryOne('SELECT * FROM human_interactions WHERE id = ?', [id]);
            if (!row)
                return null;
            return parseHumanInteraction(row);
        },
        listPending: (executionId) => {
            if (rdb.isClosed)
                return [];
            const scopedExecutionId = executionId ?? getCurrentExecutionId();
            if (!scopedExecutionId)
                return [];
            const rows = scopedExecutionId === '*'
                ? rdb.query("SELECT * FROM human_interactions WHERE status = 'pending'")
                : rdb.query("SELECT * FROM human_interactions WHERE execution_id = ? AND status = 'pending'", [scopedExecutionId]);
            return rows.map((row) => parseHumanInteraction(row));
        }
    };
}
//# sourceMappingURL=human.js.map