// Smithers Database - SQLite-based state management
// Single source of truth for all orchestration state
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { ReactiveDatabase } from '../reactive-sqlite/index.js';
// Types are re-exported from './types.js' at the bottom of this file
// Import modules
import { createStateModule } from './state.js';
import { createMemoriesModule } from './memories.js';
import { createExecutionModule } from './execution.js';
import { createPhasesModule } from './phases.js';
import { createAgentsModule } from './agents.js';
import { createStepsModule } from './steps.js';
import { createTasksModule } from './tasks.js';
import { createToolsModule } from './tools.js';
import { createArtifactsModule } from './artifacts.js';
import { createHumanModule } from './human.js';
import { createVcsModule } from './vcs.js';
import { createQueryModule } from './query.js';
import { createRenderFramesModule } from './render-frames.js';
import { createBuildStateModule } from './build-state.js';
import { createVCSQueueModule } from './vcs-queue.js';
/**
 * Run database migrations for existing databases.
 * This ensures new columns are added to tables that were created before schema updates.
 */
function runMigrations(rdb) {
    // Migration: Add log_path column to agents table if it doesn't exist
    const agentsColumns = rdb.query('PRAGMA table_info(agents)');
    const hasLogPath = agentsColumns.some((col) => col.name === 'log_path');
    if (!hasLogPath) {
        rdb.exec('ALTER TABLE agents ADD COLUMN log_path TEXT');
    }
    const hasStreamSummary = agentsColumns.some((col) => col.name === 'stream_summary');
    if (!hasStreamSummary) {
        rdb.exec('ALTER TABLE agents ADD COLUMN stream_summary TEXT');
    }
    // Migration: Add agent_stream_events table if missing
    const streamEventsTable = rdb.query("SELECT name FROM sqlite_master WHERE type = 'table' AND name = 'agent_stream_events'");
    if (streamEventsTable.length === 0) {
        rdb.exec(`
      CREATE TABLE IF NOT EXISTS agent_stream_events (
        id TEXT PRIMARY KEY,
        agent_id TEXT NOT NULL REFERENCES agents(id) ON DELETE CASCADE,
        event_type TEXT NOT NULL,
        event_id TEXT,
        tool_name TEXT,
        content TEXT,
        timestamp INTEGER NOT NULL,
        created_at TEXT NOT NULL
      )
    `);
        rdb.exec('CREATE INDEX IF NOT EXISTS idx_agent_stream_events_agent ON agent_stream_events(agent_id)');
        rdb.exec('CREATE INDEX IF NOT EXISTS idx_agent_stream_events_type ON agent_stream_events(event_type)');
        rdb.exec('CREATE INDEX IF NOT EXISTS idx_agent_stream_events_created ON agent_stream_events(created_at DESC)');
    }
    // Migration: Add interactive session columns to human_interactions table if missing
    const humanColumns = rdb.query('PRAGMA table_info(human_interactions)');
    const hasSessionConfig = humanColumns.some((col) => col.name === 'session_config');
    if (!hasSessionConfig) {
        rdb.exec('ALTER TABLE human_interactions ADD COLUMN session_config TEXT');
    }
    const hasSessionTranscript = humanColumns.some((col) => col.name === 'session_transcript');
    if (!hasSessionTranscript) {
        rdb.exec('ALTER TABLE human_interactions ADD COLUMN session_transcript TEXT');
    }
    const hasSessionDuration = humanColumns.some((col) => col.name === 'session_duration');
    if (!hasSessionDuration) {
        rdb.exec('ALTER TABLE human_interactions ADD COLUMN session_duration INTEGER');
    }
    const hasHumanError = humanColumns.some((col) => col.name === 'error');
    if (!hasHumanError) {
        rdb.exec('ALTER TABLE human_interactions ADD COLUMN error TEXT');
    }
    // Migration: Add End component columns to executions table if missing
    const executionsColumns = rdb.query('PRAGMA table_info(executions)');
    const hasEndSummary = executionsColumns.some((col) => col.name === 'end_summary');
    if (!hasEndSummary) {
        rdb.exec('ALTER TABLE executions ADD COLUMN end_summary TEXT');
    }
    const hasEndReason = executionsColumns.some((col) => col.name === 'end_reason');
    if (!hasEndReason) {
        rdb.exec('ALTER TABLE executions ADD COLUMN end_reason TEXT');
    }
    const hasExitCode = executionsColumns.some((col) => col.name === 'exit_code');
    if (!hasExitCode) {
        rdb.exec('ALTER TABLE executions ADD COLUMN exit_code INTEGER DEFAULT 0');
    }
}
/**
 * Create a Smithers database instance
 */
export function createSmithersDB(options = {}) {
    // Determine database path
    const dbPath = options.path ?? ':memory:';
    // Create ReactiveDatabase
    const rdb = new ReactiveDatabase(dbPath);
    // Initialize schema
    let schemaPath;
    try {
        const currentFileUrl = import.meta.url;
        if (currentFileUrl.startsWith('file://')) {
            const currentDir = path.dirname(fileURLToPath(currentFileUrl));
            schemaPath = path.join(currentDir, 'schema.sql');
        }
        else {
            schemaPath = path.resolve(process.cwd(), 'src/db/schema.sql');
        }
    }
    catch {
        schemaPath = path.resolve(process.cwd(), 'src/db/schema.sql');
    }
    // Reset if requested
    if (options.reset) {
        const tables = ['render_frames', 'tasks', 'steps', 'reviews', 'snapshots', 'commits', 'reports', 'artifacts',
            'transitions', 'state', 'tool_calls', 'agent_stream_events', 'agents', 'phases', 'executions',
            'memories', 'human_interactions'];
        for (const table of tables) {
            try {
                rdb.exec(`DROP TABLE IF EXISTS ${table}`);
            }
            catch (err) {
                console.warn(`[SmithersDB] Failed to drop table ${table}:`, err);
            }
        }
    }
    // Execute schema
    const schemaSql = fs.readFileSync(schemaPath, 'utf-8');
    rdb.exec(schemaSql);
    // Run migrations for existing databases
    runMigrations(rdb);
    // Track current execution context
    let currentExecutionId = null;
    let currentPhaseId = null;
    let currentAgentId = null;
    let currentStepId = null;
    // Context getters and setters for modules
    const getCurrentExecutionId = () => currentExecutionId;
    const setCurrentExecutionId = (id) => { currentExecutionId = id; };
    const getCurrentPhaseId = () => currentPhaseId;
    const setCurrentPhaseId = (id) => { currentPhaseId = id; };
    const getCurrentAgentId = () => currentAgentId;
    const setCurrentAgentId = (id) => { currentAgentId = id; };
    const getCurrentStepId = () => currentStepId;
    const setCurrentStepId = (id) => { currentStepId = id; };
    // Create all modules
    const state = createStateModule({ rdb, getCurrentExecutionId });
    const memories = createMemoriesModule({ rdb, getCurrentExecutionId });
    const execution = createExecutionModule({ rdb, getCurrentExecutionId, setCurrentExecutionId });
    const phases = createPhasesModule({ rdb, getCurrentExecutionId, getCurrentPhaseId, setCurrentPhaseId });
    const agents = createAgentsModule({ rdb, getCurrentExecutionId, getCurrentPhaseId, getCurrentAgentId, setCurrentAgentId });
    const steps = createStepsModule({ rdb, getCurrentExecutionId, getCurrentPhaseId, getCurrentStepId, setCurrentStepId });
    const tasks = createTasksModule({ rdb, getCurrentExecutionId });
    const tools = createToolsModule({ rdb, getCurrentExecutionId });
    const artifacts = createArtifactsModule({ rdb, getCurrentExecutionId });
    const human = createHumanModule({ rdb, getCurrentExecutionId });
    const vcs = createVcsModule({ rdb, getCurrentExecutionId });
    const renderFrames = createRenderFramesModule({ rdb, getCurrentExecutionId });
    const buildState = createBuildStateModule({ rdb });
    const vcsQueue = createVCSQueueModule({ rdb, getCurrentExecutionId });
    const query = createQueryModule({ rdb });
    const db = {
        db: rdb,
        state,
        memories,
        execution,
        phases,
        agents,
        steps,
        tasks,
        tools,
        artifacts,
        human,
        vcs,
        renderFrames,
        buildState,
        vcsQueue,
        query,
        close: () => {
            rdb.close();
        },
    };
    return db;
}
// Re-export types
export * from './types.js';
// Re-export reactive-sqlite for direct use
export { ReactiveDatabase, useQuery, useMutation, useQueryOne, useQueryValue } from '../reactive-sqlite/index.js';
//# sourceMappingURL=index.js.map