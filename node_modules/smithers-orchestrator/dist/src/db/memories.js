// Memory CRUD operations module for Smithers DB
import { uuid, now } from './utils.js';
export function createMemoriesModule(ctx) {
    const { rdb, getCurrentExecutionId } = ctx;
    const memories = {
        add: (memory) => {
            if (rdb.isClosed)
                return uuid();
            const id = uuid();
            rdb.run(`INSERT INTO memories (id, category, scope, key, content, confidence, source, source_execution_id, created_at, updated_at, accessed_at, expires_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, [id, memory.category, memory.scope ?? 'global', memory.key, memory.content,
                memory.confidence ?? 1.0, memory.source ?? null, getCurrentExecutionId(),
                now(), now(), now(), memory.expires_at?.toISOString() ?? null]);
            return id;
        },
        get: (category, key, scope) => {
            if (rdb.isClosed)
                return null;
            const row = rdb.queryOne(`SELECT * FROM memories WHERE category = ? AND key = ? AND (scope = ? OR ? IS NULL)`, [category, key, scope ?? null, scope ?? null]);
            if (row) {
                rdb.run('UPDATE memories SET accessed_at = ? WHERE id = ?', [now(), row.id]);
            }
            return row;
        },
        list: (category, scope, limit = 100) => {
            if (rdb.isClosed)
                return [];
            let sql = 'SELECT * FROM memories WHERE 1=1';
            const params = [];
            if (category) {
                sql += ' AND category = ?';
                params.push(category);
            }
            if (scope) {
                sql += ' AND scope = ?';
                params.push(scope);
            }
            sql += ' ORDER BY created_at DESC LIMIT ?';
            params.push(limit);
            return rdb.query(sql, params);
        },
        search: (query, category, limit = 20) => {
            if (rdb.isClosed)
                return [];
            const escapeLike = (s) => s.replace(/[%_\\]/g, '\\$&');
            let sql = "SELECT * FROM memories WHERE content LIKE ? ESCAPE '\\'";
            const params = [`%${escapeLike(query)}%`];
            if (category) {
                sql += ' AND category = ?';
                params.push(category);
            }
            sql += ' ORDER BY created_at DESC LIMIT ?';
            params.push(limit);
            return rdb.query(sql, params);
        },
        update: (id, updates) => {
            if (rdb.isClosed)
                return;
            const sets = ['updated_at = ?'];
            const params = [now()];
            if (updates.content !== undefined) {
                sets.push('content = ?');
                params.push(updates.content);
            }
            if (updates.confidence !== undefined) {
                sets.push('confidence = ?');
                params.push(updates.confidence);
            }
            if (updates.expires_at !== undefined) {
                sets.push('expires_at = ?');
                params.push(updates.expires_at?.toISOString() ?? null);
            }
            params.push(id);
            rdb.run(`UPDATE memories SET ${sets.join(', ')} WHERE id = ?`, params);
        },
        delete: (id) => {
            if (rdb.isClosed)
                return;
            rdb.run('DELETE FROM memories WHERE id = ?', [id]);
        },
        addFact: (key, content, source) => {
            return memories.add({ category: 'fact', key, content, ...(source ? { source } : {}) });
        },
        addLearning: (key, content, source) => {
            return memories.add({ category: 'learning', key, content, ...(source ? { source } : {}) });
        },
        addPreference: (key, content, scope) => {
            return memories.add({ category: 'preference', key, content, ...(scope ? { scope } : {}) });
        },
        stats: () => {
            const total = rdb.queryValue('SELECT COUNT(*) FROM memories') ?? 0;
            const byCategory = {};
            const byCategoryRows = rdb.query('SELECT category, COUNT(*) as count FROM memories GROUP BY category');
            for (const row of byCategoryRows)
                byCategory[row.category] = row.count;
            const byScope = {};
            const byScopeRows = rdb.query('SELECT scope, COUNT(*) as count FROM memories GROUP BY scope');
            for (const row of byScopeRows)
                byScope[row.scope] = row.count;
            return { total, byCategory, byScope };
        },
    };
    return memories;
}
//# sourceMappingURL=memories.js.map