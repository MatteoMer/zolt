// Task tracking module for Ralph iteration management
// Replaces React state-based task tracking with database-backed tracking
import { uuid, now, parseJson } from './utils.js';
export function createTasksModule(ctx) {
    const { rdb, getCurrentExecutionId } = ctx;
    const tasks = {
        start: (componentType, componentName) => {
            if (rdb.isClosed) {
                return uuid();
            }
            const executionId = getCurrentExecutionId();
            if (!executionId)
                throw new Error('No active execution');
            // Get current iteration from state
            const iteration = tasks.getCurrentIteration();
            const id = uuid();
            rdb.run(`INSERT INTO tasks (id, execution_id, iteration, component_type, component_name, status, started_at)
         VALUES (?, ?, ?, ?, ?, 'running', ?)`, [id, executionId, iteration, componentType, componentName ?? null, now()]);
            return id;
        },
        complete: (id) => {
            if (rdb.isClosed)
                return;
            const startRow = rdb.queryOne('SELECT started_at FROM tasks WHERE id = ?', [id]);
            const durationMs = startRow ? Date.now() - new Date(startRow.started_at).getTime() : null;
            rdb.run(`UPDATE tasks SET status = 'completed', completed_at = ?, duration_ms = ? WHERE id = ?`, [now(), durationMs, id]);
        },
        fail: (id) => {
            if (rdb.isClosed)
                return;
            const startRow = rdb.queryOne('SELECT started_at FROM tasks WHERE id = ?', [id]);
            const durationMs = startRow ? Date.now() - new Date(startRow.started_at).getTime() : null;
            rdb.run(`UPDATE tasks SET status = 'failed', completed_at = ?, duration_ms = ? WHERE id = ?`, [now(), durationMs, id]);
        },
        getRunningCount: (iteration) => {
            if (rdb.isClosed)
                return 0;
            const executionId = getCurrentExecutionId();
            if (!executionId)
                return 0;
            const result = rdb.queryOne(`SELECT COUNT(*) as count FROM tasks WHERE execution_id = ? AND iteration = ? AND status = 'running'`, [executionId, iteration]);
            return result?.count ?? 0;
        },
        getTotalCount: (iteration) => {
            if (rdb.isClosed)
                return 0;
            const executionId = getCurrentExecutionId();
            if (!executionId)
                return 0;
            const result = rdb.queryOne(`SELECT COUNT(*) as count FROM tasks WHERE execution_id = ? AND iteration = ?`, [executionId, iteration]);
            return result?.count ?? 0;
        },
        list: () => {
            if (rdb.isClosed)
                return [];
            const executionId = getCurrentExecutionId();
            if (!executionId)
                return [];
            return rdb.query('SELECT * FROM tasks WHERE execution_id = ? ORDER BY started_at', [executionId]);
        },
        getCurrentIteration: () => {
            if (rdb.isClosed)
                return 0;
            const result = rdb.queryOne("SELECT value FROM state WHERE key = 'ralphCount'");
            return parseJson(result?.value, 0);
        },
        withTask: async (componentType, componentName, fn) => {
            const taskId = tasks.start(componentType, componentName);
            try {
                const result = await fn();
                tasks.complete(taskId);
                return result;
            }
            catch (error) {
                tasks.fail(taskId);
                throw error;
            }
        },
    };
    return tasks;
}
//# sourceMappingURL=tasks.js.map