export function createVCSQueueModule(ctx) {
    const { rdb, getCurrentExecutionId } = ctx;
    return {
        enqueue(operation, payload) {
            const executionId = getCurrentExecutionId();
            const result = rdb.run(`INSERT INTO vcs_queue (execution_id, operation, payload, status) VALUES (?, ?, ?, 'pending')`, [executionId, operation, JSON.stringify(payload)]);
            return Number(result.lastInsertRowid);
        },
        dequeue() {
            const item = rdb.queryOne(`SELECT * FROM vcs_queue WHERE status = 'pending' ORDER BY id LIMIT 1`);
            if (!item)
                return null;
            rdb.run(`UPDATE vcs_queue SET status = 'running', started_at = datetime('now') WHERE id = ?`, [item.id]);
            return {
                ...item,
                payload: JSON.parse(item.payload)
            };
        },
        complete(id, error) {
            rdb.run(`UPDATE vcs_queue SET status = ?, completed_at = datetime('now'), error = ? WHERE id = ?`, [error ? 'failed' : 'done', error ?? null, id]);
        },
        getPending() {
            return rdb.query(`SELECT * FROM vcs_queue WHERE status = 'pending' ORDER BY id`).map(item => ({ ...item, payload: JSON.parse(item.payload) }));
        }
    };
}
//# sourceMappingURL=vcs-queue.js.map