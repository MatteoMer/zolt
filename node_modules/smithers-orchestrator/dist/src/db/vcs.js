// VCS/commit/snapshot/review tracking module for Smithers DB
import { uuid, now, parseJson } from './utils.js';
const mapCommit = (row) => {
    if (!row)
        return null;
    return {
        id: row.id,
        execution_id: row.execution_id,
        agent_id: row.agent_id ?? undefined,
        vcs_type: row.vcs_type,
        commit_hash: row.commit_hash,
        change_id: row.change_id ?? undefined,
        message: row.message,
        author: row.author ?? undefined,
        files_changed: row.files_changed ? parseJson(row.files_changed, []) : undefined,
        insertions: row.insertions ?? undefined,
        deletions: row.deletions ?? undefined,
        smithers_metadata: row.smithers_metadata ? parseJson(row.smithers_metadata, {}) : undefined,
        created_at: new Date(row.created_at),
    };
};
const mapSnapshot = (row) => {
    if (!row)
        return null;
    return {
        id: row.id,
        execution_id: row.execution_id,
        change_id: row.change_id,
        commit_hash: row.commit_hash ?? undefined,
        description: row.description ?? undefined,
        files_modified: row.files_modified ? parseJson(row.files_modified, []) : undefined,
        files_added: row.files_added ? parseJson(row.files_added, []) : undefined,
        files_deleted: row.files_deleted ? parseJson(row.files_deleted, []) : undefined,
        has_conflicts: row.has_conflicts === 1,
        created_at: new Date(row.created_at),
    };
};
const mapReview = (row) => {
    if (!row)
        return null;
    return {
        id: row.id,
        execution_id: row.execution_id,
        agent_id: row.agent_id ?? undefined,
        target_type: row.target_type,
        target_ref: row.target_ref ?? undefined,
        approved: row.approved === 1,
        summary: row.summary,
        issues: parseJson(row.issues, []),
        approvals: row.approvals ? parseJson(row.approvals, []) : undefined,
        reviewer_model: row.reviewer_model ?? undefined,
        blocking: row.blocking === 1,
        posted_to_github: row.posted_to_github === 1,
        posted_to_git_notes: row.posted_to_git_notes === 1,
        created_at: new Date(row.created_at),
    };
};
const mapReport = (row) => {
    if (!row)
        return null;
    return {
        id: row.id,
        execution_id: row.execution_id,
        agent_id: row.agent_id ?? undefined,
        type: row.type,
        title: row.title,
        content: row.content,
        data: row.data ? parseJson(row.data, {}) : undefined,
        severity: row.severity,
        created_at: new Date(row.created_at),
    };
};
export function createVcsModule(ctx) {
    const { rdb, getCurrentExecutionId } = ctx;
    const vcs = {
        logCommit: (commit) => {
            if (rdb.isClosed)
                return uuid();
            const currentExecutionId = getCurrentExecutionId();
            if (!currentExecutionId)
                throw new Error('No active execution');
            const id = uuid();
            rdb.run(`INSERT OR REPLACE INTO commits (id, execution_id, agent_id, vcs_type, commit_hash, change_id, message, author, files_changed, insertions, deletions, smithers_metadata, created_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, [id, currentExecutionId, commit.agent_id ?? null, commit.vcs_type, commit.commit_hash,
                commit.change_id ?? null, commit.message, commit.author ?? null,
                commit.files_changed ? JSON.stringify(commit.files_changed) : null,
                commit.insertions ?? null, commit.deletions ?? null,
                commit.smithers_metadata ? JSON.stringify(commit.smithers_metadata) : null, now()]);
            return id;
        },
        getCommits: (limit = 50) => {
            if (rdb.isClosed)
                return [];
            const currentExecutionId = getCurrentExecutionId();
            if (!currentExecutionId)
                return [];
            return rdb.query('SELECT * FROM commits WHERE execution_id = ? ORDER BY created_at DESC LIMIT ?', [currentExecutionId, limit])
                .map(mapCommit)
                .filter((c) => c !== null);
        },
        getCommit: (hash, vcsType) => {
            if (rdb.isClosed)
                return null;
            if (vcsType) {
                return mapCommit(rdb.queryOne('SELECT * FROM commits WHERE commit_hash = ? AND vcs_type = ?', [hash, vcsType]));
            }
            return mapCommit(rdb.queryOne('SELECT * FROM commits WHERE commit_hash = ?', [hash]));
        },
        logSnapshot: (snapshot) => {
            if (rdb.isClosed)
                return uuid();
            const currentExecutionId = getCurrentExecutionId();
            if (!currentExecutionId)
                throw new Error('No active execution');
            const id = uuid();
            rdb.run(`INSERT INTO snapshots (id, execution_id, change_id, commit_hash, description, files_modified, files_added, files_deleted, has_conflicts, created_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, [id, currentExecutionId, snapshot.change_id, snapshot.commit_hash ?? null,
                snapshot.description ?? null,
                snapshot.files_modified ? JSON.stringify(snapshot.files_modified) : null,
                snapshot.files_added ? JSON.stringify(snapshot.files_added) : null,
                snapshot.files_deleted ? JSON.stringify(snapshot.files_deleted) : null,
                snapshot.has_conflicts ? 1 : 0, now()]);
            return id;
        },
        getSnapshots: (limit = 50) => {
            if (rdb.isClosed)
                return [];
            const currentExecutionId = getCurrentExecutionId();
            if (!currentExecutionId)
                return [];
            return rdb.query('SELECT * FROM snapshots WHERE execution_id = ? ORDER BY created_at DESC LIMIT ?', [currentExecutionId, limit])
                .map(mapSnapshot)
                .filter((s) => s !== null);
        },
        logReview: (review) => {
            if (rdb.isClosed)
                return uuid();
            const currentExecutionId = getCurrentExecutionId();
            if (!currentExecutionId)
                throw new Error('No active execution');
            const id = uuid();
            rdb.run(`INSERT INTO reviews (id, execution_id, agent_id, target_type, target_ref, approved, summary, issues, approvals, reviewer_model, blocking, created_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, [id, currentExecutionId, review.agent_id ?? null, review.target_type,
                review.target_ref ?? null, review.approved ? 1 : 0, review.summary,
                JSON.stringify(review.issues), review.approvals ? JSON.stringify(review.approvals) : null,
                review.reviewer_model ?? null, review.blocking ? 1 : 0, now()]);
            return id;
        },
        updateReview: (id, updates) => {
            if (rdb.isClosed)
                return;
            const sets = [];
            const params = [];
            if (updates.posted_to_github !== undefined) {
                sets.push('posted_to_github = ?');
                params.push(updates.posted_to_github ? 1 : 0);
            }
            if (updates.posted_to_git_notes !== undefined) {
                sets.push('posted_to_git_notes = ?');
                params.push(updates.posted_to_git_notes ? 1 : 0);
            }
            if (sets.length > 0) {
                params.push(id);
                rdb.run(`UPDATE reviews SET ${sets.join(', ')} WHERE id = ?`, params);
            }
        },
        getReviews: (limit = 50) => {
            if (rdb.isClosed)
                return [];
            const currentExecutionId = getCurrentExecutionId();
            if (!currentExecutionId)
                return [];
            return rdb.query('SELECT * FROM reviews WHERE execution_id = ? ORDER BY created_at DESC LIMIT ?', [currentExecutionId, limit])
                .map(mapReview)
                .filter((r) => r !== null);
        },
        getBlockingReviews: () => {
            if (rdb.isClosed)
                return [];
            const currentExecutionId = getCurrentExecutionId();
            if (!currentExecutionId)
                return [];
            return rdb.query('SELECT * FROM reviews WHERE execution_id = ? AND blocking = 1 AND approved = 0', [currentExecutionId])
                .map(mapReview)
                .filter((r) => r !== null);
        },
        addReport: (report) => {
            if (rdb.isClosed)
                return uuid();
            const currentExecutionId = getCurrentExecutionId();
            if (!currentExecutionId)
                throw new Error('No active execution');
            const id = uuid();
            rdb.run(`INSERT INTO reports (id, execution_id, agent_id, type, title, content, data, severity, created_at)
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`, [id, currentExecutionId, report.agent_id ?? null, report.type, report.title, report.content,
                report.data ? JSON.stringify(report.data) : null, report.severity ?? 'info', now()]);
            return id;
        },
        getReports: (type, limit = 100) => {
            if (rdb.isClosed)
                return [];
            const currentExecutionId = getCurrentExecutionId();
            if (!currentExecutionId)
                return [];
            let sql = 'SELECT * FROM reports WHERE execution_id = ?';
            const params = [currentExecutionId];
            if (type) {
                sql += ' AND type = ?';
                params.push(type);
            }
            sql += ' ORDER BY created_at DESC LIMIT ?';
            params.push(limit);
            return rdb.query(sql, params)
                .map(mapReport)
                .filter((r) => r !== null);
        },
        getCriticalReports: () => {
            if (rdb.isClosed)
                return [];
            const currentExecutionId = getCurrentExecutionId();
            if (!currentExecutionId)
                return [];
            return rdb.query("SELECT * FROM reports WHERE execution_id = ? AND severity = 'critical' ORDER BY created_at DESC", [currentExecutionId])
                .map(mapReport)
                .filter((r) => r !== null);
        },
    };
    return vcs;
}
//# sourceMappingURL=vcs.js.map