/**
 * Debug and observability utilities
 */
const SECRET_PATTERNS = [
    /api[_-]?key/i,
    /token/i,
    /password/i,
    /secret/i,
    /credential/i,
    /auth/i,
    /bearer/i,
    /private[_-]?key/i,
];
function isSecretKey(key) {
    return SECRET_PATTERNS.some((pattern) => pattern.test(key));
}
export function redactSecrets(obj, seen = new WeakSet()) {
    if (obj === null || obj === undefined) {
        return obj;
    }
    if (typeof obj !== 'object') {
        return obj;
    }
    if (seen.has(obj)) {
        return '[Circular]';
    }
    seen.add(obj);
    if (Array.isArray(obj)) {
        return obj.map((item) => redactSecrets(item, seen));
    }
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
        if (isSecretKey(key)) {
            result[key] = '[REDACTED]';
        }
        else if (typeof value === 'object' && value !== null) {
            result[key] = redactSecrets(value, seen);
        }
        else {
            result[key] = value;
        }
    }
    return result;
}
function safeStringify(obj) {
    const seen = new WeakSet();
    return JSON.stringify(obj, (_key, value) => {
        if (typeof value === 'object' && value !== null) {
            if (seen.has(value)) {
                return '[Circular]';
            }
            seen.add(value);
        }
        return value;
    });
}
export function createDebugCollector() {
    return {
        emit(event) {
            const redacted = redactSecrets(event);
            const level = event['level'] || 'debug';
            switch (level) {
                case 'error':
                    console.error('[Debug]', redacted);
                    break;
                case 'warn':
                    console.warn('[Debug]', redacted);
                    break;
                case 'info':
                    console.info('[Debug]', redacted);
                    break;
                case 'debug':
                    console.debug('[Debug]', redacted);
                    break;
                default:
                    console.log('[Debug]', redacted);
            }
        },
    };
}
export { safeStringify };
let globalMinLevel = 'info';
const levelPriority = { debug: 0, info: 1, warn: 2, error: 3 };
export function setLogLevel(level) {
    globalMinLevel = level;
}
export function getLogLevel() {
    return globalMinLevel;
}
export function createLogger(component, context = {}) {
    const shouldLog = (level) => {
        return levelPriority[level] >= levelPriority[globalMinLevel];
    };
    const formatEntry = (entry) => {
        const prefix = `[${entry.component}]`;
        const suffix = entry.durationMs !== undefined ? ` (${entry.durationMs}ms)` : '';
        const dataStr = entry.data && Object.keys(entry.data).length > 0
            ? ` ${safeStringify(redactSecrets(entry.data))}`
            : '';
        return `${prefix} ${entry.message}${suffix}${dataStr}`;
    };
    const emit = (level, message, data, error) => {
        if (!shouldLog(level))
            return;
        const entry = {
            level,
            component,
            message,
            timestamp: Date.now(),
            data: { ...context, ...data },
            error,
        };
        const formatted = formatEntry(entry);
        switch (level) {
            case 'debug':
                console.debug(formatted);
                break;
            case 'info':
                console.log(formatted);
                break;
            case 'warn':
                console.warn(formatted);
                break;
            case 'error':
                console.error(formatted, error ?? '');
                break;
        }
    };
    const logger = {
        debug: (message, data) => emit('debug', message, data),
        info: (message, data) => emit('info', message, data),
        warn: (message, data) => emit('warn', message, data),
        error: (message, error, data) => emit('error', message, data, error),
        time(operation) {
            const start = performance.now();
            return () => {
                const elapsed = Math.round(performance.now() - start);
                emit('debug', `${operation} completed`, { durationMs: elapsed });
                return elapsed;
            };
        },
        child(childContext) {
            return createLogger(component, { ...context, ...childContext });
        },
    };
    return logger;
}
// ============================================================================
// ERROR WRAPPER UTILITIES
// ============================================================================
/** Wrap an async operation with error logging and optional rethrow */
export async function withErrorLogging(logger, operation, fn, options = {}) {
    const endTime = logger.time(operation);
    try {
        const result = await fn();
        endTime();
        return result;
    }
    catch (err) {
        endTime();
        const error = err instanceof Error ? err : new Error(String(err));
        logger.error(`${operation} failed`, error);
        if (options.rethrow)
            throw error;
        return options.defaultValue;
    }
}
/** Wrap a sync operation with error logging */
export function withErrorLoggingSync(logger, operation, fn, options = {}) {
    try {
        return fn();
    }
    catch (err) {
        const error = err instanceof Error ? err : new Error(String(err));
        logger.error(`${operation} failed`, error);
        if (options.rethrow)
            throw error;
        return options.defaultValue;
    }
}
//# sourceMappingURL=index.js.map