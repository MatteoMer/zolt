import { useCallback, useRef } from 'react';
import { useSmithers } from '../components/SmithersProvider.js';
import { parseHumanInteraction } from '../db/human.js';
import { parseJson, uuid } from '../db/utils.js';
import { useQueryOne, useQueryValue } from '../reactive-sqlite/index.js';
import { useEffectOnValueChange, useMount } from '../reconciler/hooks.js';
const DEFAULT_STATE = {
    status: 'idle',
    data: null,
    error: null,
    sessionId: null,
    taskId: null,
};
const mapOutcome = (status) => {
    if (status === 'completed')
        return 'completed';
    if (status === 'cancelled')
        return 'cancelled';
    if (status === 'timeout')
        return 'timeout';
    if (status === 'failed')
        return 'failed';
    return 'completed';
};
export function useHumanInteractive() {
    const { db, reactiveDb } = useSmithers();
    const stateKeyRef = useRef(`humanInteractive:${uuid()}`);
    const resolveRef = useRef(null);
    const rejectRef = useRef(null);
    const zodSchemaRef = useRef(null);
    const handledSessionIdRef = useRef(null);
    useMount(() => {
        const existing = db.state.get(stateKeyRef.current);
        if (!existing) {
            db.state.set(stateKeyRef.current, DEFAULT_STATE, 'human_interactive_init');
        }
    });
    const { data: stateJson } = useQueryValue(reactiveDb, 'SELECT value FROM state WHERE key = ?', [stateKeyRef.current]);
    const state = stateJson ? parseJson(stateJson, DEFAULT_STATE) : DEFAULT_STATE;
    const { data: sessionRow } = useQueryOne(reactiveDb, state.sessionId
        ? 'SELECT * FROM human_interactions WHERE id = ?'
        : 'SELECT 1 WHERE 0', state.sessionId ? [state.sessionId] : []);
    const session = sessionRow ? parseHumanInteraction(sessionRow) : null;
    const setState = useCallback((next, trigger) => {
        db.state.set(stateKeyRef.current, next, trigger);
    }, [db]);
    const handleCompletion = useCallback((session, current) => {
        let response = session.response;
        if (zodSchemaRef.current) {
            try {
                response = zodSchemaRef.current.parse(response);
            }
            catch (err) {
                const error = err instanceof Error ? err : new Error('Interactive response validation failed');
                setState({
                    ...current,
                    status: 'error',
                    error: error.message,
                    data: null,
                    taskId: null,
                }, 'human_interactive_validation_failed');
                if (current.taskId) {
                    db.tasks.complete(current.taskId);
                }
                rejectRef.current?.(error);
                resolveRef.current = null;
                rejectRef.current = null;
                return;
            }
        }
        const result = {
            outcome: mapOutcome(session.status),
            response,
            transcript: session.session_transcript ?? undefined,
            duration: session.session_duration ?? 0,
            error: session.error ?? undefined,
        };
        if (current.taskId) {
            db.tasks.complete(current.taskId);
        }
        const nextStatus = session.status === 'failed' ? 'error' : 'success';
        setState({
            ...current,
            status: nextStatus,
            data: nextStatus === 'success' ? result : null,
            error: nextStatus === 'error' ? (session.error ?? 'Session failed') : null,
            taskId: null,
        }, 'human_interactive_complete');
        if (nextStatus === 'error') {
            const error = new Error(session.error ?? 'Session failed');
            rejectRef.current?.(error);
        }
        else {
            resolveRef.current?.(result);
        }
        resolveRef.current = null;
        rejectRef.current = null;
    }, [db, setState]);
    useEffectOnValueChange(session?.status, () => {
        if (!session || session.status === 'pending')
            return;
        if (db.db.isClosed)
            return;
        if (handledSessionIdRef.current === session.id)
            return;
        const current = db.state.get(stateKeyRef.current) ?? DEFAULT_STATE;
        if (current.status !== 'pending')
            return;
        handledSessionIdRef.current = session.id;
        handleCompletion(session, current);
    }, [session, db, handleCompletion]);
    const createSession = useCallback((prompt, options) => {
        if (db.db.isClosed)
            throw new Error('Database is closed');
        const current = db.state.get(stateKeyRef.current) ?? DEFAULT_STATE;
        if (current.status === 'pending') {
            throw new Error('Cannot create a new interactive session while one is already pending');
        }
        const config = {
            blockOrchestration: options?.blockOrchestration ?? true,
        };
        if (options?.systemPrompt !== undefined)
            config.systemPrompt = options.systemPrompt;
        if (options?.context !== undefined)
            config.context = options.context;
        if (options?.model !== undefined)
            config.model = options.model;
        if (options?.cwd !== undefined)
            config.cwd = options.cwd;
        if (options?.mcpConfig !== undefined)
            config.mcpConfig = options.mcpConfig;
        if (options?.timeout !== undefined)
            config.timeout = options.timeout;
        if (options?.outcomeSchema !== undefined)
            config.outcomeSchema = options.outcomeSchema;
        if (options?.captureTranscript !== undefined)
            config.captureTranscript = options.captureTranscript;
        const id = db.human.requestInteractive(prompt, config);
        let taskId = null;
        if (config.blockOrchestration) {
            taskId = db.tasks.start('human_interactive', `Interactive session: ${prompt.slice(0, 50)}...`);
        }
        setState({
            status: 'pending',
            data: null,
            error: null,
            sessionId: id,
            taskId,
        }, 'human_interactive_request');
        return id;
    }, [db, setState]);
    const request = useCallback((prompt, options) => {
        zodSchemaRef.current = options?.zodSchema ?? null;
        createSession(prompt, options);
    }, [createSession]);
    const requestAsync = useCallback((prompt, options) => {
        zodSchemaRef.current = options?.zodSchema ?? null;
        return new Promise((resolve, reject) => {
            resolveRef.current = resolve;
            rejectRef.current = reject;
            createSession(prompt, options);
        });
    }, [createSession]);
    const cancel = useCallback(() => {
        if (state.sessionId && state.status === 'pending') {
            db.human.cancelInteractive(state.sessionId);
            if (state.taskId) {
                db.tasks.complete(state.taskId);
            }
        }
    }, [state, db]);
    const reset = useCallback(() => {
        if (state.taskId) {
            db.tasks.complete(state.taskId);
        }
        setState(DEFAULT_STATE, 'human_interactive_reset');
        resolveRef.current = null;
        rejectRef.current = null;
        zodSchemaRef.current = null;
        handledSessionIdRef.current = null;
    }, [state.taskId, setState]);
    return {
        request,
        requestAsync,
        status: state.status,
        data: state.data,
        error: state.error ? new Error(state.error) : null,
        sessionId: state.sessionId,
        cancel,
        reset,
    };
}
//# sourceMappingURL=useHumanInteractive.js.map