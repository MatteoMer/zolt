export class LRUCache {
    constructor(options) {
        this.cache = new Map();
        this.max = options.max;
    }
    get(key) {
        const entry = this.cache.get(key);
        if (!entry)
            return null;
        if (entry.expiresAt && Date.now() > entry.expiresAt) {
            this.cache.delete(key);
            return null;
        }
        this.cache.delete(key);
        this.cache.set(key, entry);
        return entry.value;
    }
    set(key, value, ttlSeconds) {
        if (this.cache.has(key)) {
            this.cache.delete(key);
        }
        else if (this.cache.size >= this.max) {
            const firstKey = this.cache.keys().next().value;
            if (firstKey !== undefined) {
                this.cache.delete(firstKey);
            }
        }
        const entry = { value };
        if (ttlSeconds) {
            entry.expiresAt = Date.now() + ttlSeconds * 1000;
        }
        this.cache.set(key, entry);
    }
}
function stableStringify(value) {
    const seen = new WeakSet();
    const replacer = (_key, val) => {
        if (typeof val === 'function' || typeof val === 'symbol') {
            return undefined;
        }
        if (val && typeof val === 'object') {
            if (seen.has(val))
                return '[circular]';
            seen.add(val);
            if ('safeParse' in val) {
                return '[zod-schema]';
            }
        }
        return val;
    };
    return JSON.stringify(value, replacer);
}
function defaultCacheKey(options) {
    const { onProgress: _onProgress, onToolCall: _onToolCall, schema, ...rest } = options;
    return stableStringify({ ...rest, schema: schema ? '[schema]' : undefined });
}
export function cachingMiddleware(options) {
    const keyFn = options.keyFn ?? defaultCacheKey;
    return {
        name: 'caching',
        wrapExecute: async ({ doExecute, options: executionOptions }) => {
            const key = keyFn(executionOptions);
            const cached = await options.cache.get(key);
            if (cached) {
                return cached;
            }
            const result = await doExecute();
            await options.cache.set(key, result, options.ttl);
            return result;
        },
    };
}
//# sourceMappingURL=caching.js.map