function filterMiddleware(middlewares) {
    return middlewares.filter(Boolean);
}
function buildProgressTransformer(middlewares, onProgress) {
    if (!onProgress)
        return undefined;
    const transformers = middlewares.map((mw) => mw.transformChunk).filter(Boolean);
    if (transformers.length === 0)
        return onProgress;
    return (chunk) => {
        let nextChunk = chunk;
        for (const transform of transformers) {
            nextChunk = transform(nextChunk);
        }
        onProgress(nextChunk);
    };
}
/**
 * Compose multiple middleware into a single middleware.
 */
export function composeMiddleware(...middlewares) {
    const active = filterMiddleware(middlewares);
    if (active.length === 0) {
        return {};
    }
    const name = active.map((mw) => mw.name).filter(Boolean).join('+');
    const composed = {
        transformOptions: async (options) => {
            let nextOptions = options;
            for (const mw of active) {
                if (mw.transformOptions) {
                    nextOptions = await mw.transformOptions(nextOptions);
                }
            }
            const onProgress = buildProgressTransformer(active, nextOptions.onProgress);
            return onProgress ? { ...nextOptions, onProgress } : nextOptions;
        },
        wrapExecute: async ({ doExecute, options }) => {
            let wrapped = doExecute;
            for (const mw of [...active].reverse()) {
                if (!mw.wrapExecute)
                    continue;
                const previous = wrapped;
                wrapped = () => mw.wrapExecute({ doExecute: previous, options });
            }
            return wrapped();
        },
        transformResult: async (result) => {
            let nextResult = result;
            for (const mw of active) {
                if (mw.transformResult) {
                    nextResult = await mw.transformResult(nextResult);
                }
            }
            return nextResult;
        },
    };
    if (active.some((mw) => mw.transformChunk)) {
        composed.transformChunk = (chunk) => {
            let nextChunk = chunk;
            for (const mw of active) {
                if (mw.transformChunk) {
                    nextChunk = mw.transformChunk(nextChunk);
                }
            }
            return nextChunk;
        };
    }
    if (name) {
        composed.name = name;
    }
    return composed;
}
/**
 * Apply middleware to an execution function.
 */
export async function applyMiddleware(execute, options, middlewares) {
    const active = filterMiddleware(middlewares);
    if (active.length === 0) {
        return execute(options);
    }
    let nextOptions = options;
    for (const mw of active) {
        if (mw.transformOptions) {
            nextOptions = await mw.transformOptions(nextOptions);
        }
    }
    const onProgress = buildProgressTransformer(active, nextOptions.onProgress);
    if (onProgress) {
        nextOptions = { ...nextOptions, onProgress };
    }
    const executeWithTransforms = async () => {
        let result = await execute(nextOptions);
        for (const mw of active) {
            if (mw.transformResult) {
                result = await mw.transformResult(result);
            }
        }
        return result;
    };
    let wrappedExecute = executeWithTransforms;
    for (const mw of [...active].reverse()) {
        if (!mw.wrapExecute)
            continue;
        const previous = wrappedExecute;
        wrappedExecute = () => mw.wrapExecute({ doExecute: previous, options: nextOptions });
    }
    return wrappedExecute();
}
//# sourceMappingURL=compose.js.map