function calculateBackoff(attempt, backoff, baseDelayMs) {
    if (backoff === 'linear') {
        return baseDelayMs * (attempt + 1);
    }
    return baseDelayMs * Math.pow(2, attempt);
}
export function retryMiddleware(options = {}) {
    const maxRetries = options.maxRetries ?? 3;
    const backoff = options.backoff ?? 'exponential';
    const baseDelayMs = options.baseDelayMs ?? 250;
    const retryOn = options.retryOn ?? (() => true);
    return {
        name: 'retry',
        wrapExecute: async ({ doExecute }) => {
            let lastError = null;
            for (let attempt = 0; attempt <= maxRetries; attempt += 1) {
                try {
                    return await doExecute();
                }
                catch (error) {
                    lastError = error instanceof Error ? error : new Error(String(error));
                    if (attempt >= maxRetries || !retryOn(lastError)) {
                        throw lastError;
                    }
                    const delay = calculateBackoff(attempt, backoff, baseDelayMs);
                    const retryAttempt = attempt + 1;
                    await options.onRetry?.(retryAttempt, lastError, delay);
                    await new Promise((resolve) => setTimeout(resolve, delay));
                }
            }
            throw lastError ?? new Error('Retry middleware failed without error');
        },
    };
}
//# sourceMappingURL=retry.js.map