/**
 * ReactiveDatabase - A reactive wrapper around bun:sqlite
 *
 * Provides automatic query invalidation when data changes.
 */
import { Database } from "bun:sqlite";
import type { SubscriptionCallback, ReactiveDatabaseConfig } from "./types.js";
/**
 * ReactiveDatabase wraps bun:sqlite with reactive subscriptions
 *
 * @example
 * ```ts
 * const db = new ReactiveDatabase({ path: 'mydb.sqlite' })
 *
 * // Execute schema
 * db.exec(`CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)`)
 *
 * // Query with auto-tracking
 * const users = db.query('SELECT * FROM users').all()
 *
 * // Mutations auto-invalidate
 * db.run('INSERT INTO users (name) VALUES (?)', ['Alice'])
 * ```
 */
export declare class ReactiveDatabase {
    private db;
    private subscriptions;
    private nextSubscriptionId;
    private closed;
    constructor(config: ReactiveDatabaseConfig | string);
    /**
     * Get the underlying bun:sqlite Database instance
     */
    get raw(): Database;
    /**
     * Execute raw SQL (for schema, pragmas, etc.)
     */
    exec(sql: string): void;
    /**
     * Prepare a statement for repeated execution
     */
    prepare<T = unknown>(sql: string): import("bun:sqlite").Statement<T, any[]>;
    /**
     * Run a write operation (INSERT, UPDATE, DELETE)
     * Auto-invalidates affected queries with row-level granularity when possible
     */
    run(sql: string, params?: any[]): Database["run"] extends (...args: any[]) => infer R ? R : never;
    /**
     * Execute a query and return all rows
     */
    query<T = Record<string, unknown>>(sql: string, params?: any[]): T[];
    /**
     * Execute a query and return the first row
     */
    queryOne<T = Record<string, unknown>>(sql: string, params?: any[]): T | null;
    /**
     * Execute a query and return a single value
     */
    queryValue<T = unknown>(sql: string, params?: any[]): T | null;
    /**
     * Subscribe to changes on specific tables
     * Returns unsubscribe function
     */
    subscribe(tables: string[], callback: SubscriptionCallback): () => void;
    /**
     * Subscribe to a specific query
     * Automatically detects which tables are involved
     */
    subscribeQuery(sql: string, callback: SubscriptionCallback): () => void;
    /**
     * Subscribe to a query with row-level filtering
     * Only triggers when the specific row is modified
     */
    subscribeWithRowFilter(sql: string, params: unknown[], callback: SubscriptionCallback): () => void;
    /**
     * Invalidate subscriptions for specific rows
     */
    invalidateRows(table: string, column: string, values: (string | number)[]): void;
    /**
     * Invalidate with row filter - triggers row-level subscriptions that match
     * and falls back to table-level for subscriptions without row filters
     */
    private invalidateWithRowFilter;
    /**
     * Invalidate queries that depend on the given tables
     * If no tables specified, invalidates all queries
     */
    invalidate(tables?: string[]): void;
    /**
     * Run a function in a transaction
     */
    transaction<T>(fn: () => T): T;
    /**
     * Close the database connection
     */
    close(): void;
    /**
     * Check if database is closed
     */
    get isClosed(): boolean;
}
/**
 * Create a new ReactiveDatabase instance
 */
export declare function createReactiveDatabase(config: ReactiveDatabaseConfig | string): ReactiveDatabase;
//# sourceMappingURL=database.d.ts.map