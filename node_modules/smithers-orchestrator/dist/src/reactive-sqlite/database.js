/**
 * ReactiveDatabase - A reactive wrapper around bun:sqlite
 *
 * Provides automatic query invalidation when data changes.
 */
import { Database } from "bun:sqlite";
import { extractReadTables, extractWriteTables, isWriteOperation, extractRowFilter, } from "./parser.js";
/**
 * ReactiveDatabase wraps bun:sqlite with reactive subscriptions
 *
 * @example
 * ```ts
 * const db = new ReactiveDatabase({ path: 'mydb.sqlite' })
 *
 * // Execute schema
 * db.exec(`CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT)`)
 *
 * // Query with auto-tracking
 * const users = db.query('SELECT * FROM users').all()
 *
 * // Mutations auto-invalidate
 * db.run('INSERT INTO users (name) VALUES (?)', ['Alice'])
 * ```
 */
export class ReactiveDatabase {
    constructor(config) {
        this.subscriptions = new Map();
        this.nextSubscriptionId = 0;
        this.closed = false;
        const options = typeof config === "string" ? { path: config } : config;
        this.db = new Database(options.path, {
            create: options.create ?? true,
            readonly: options.readonly ?? false,
        });
        // Enable WAL mode for better concurrent performance
        this.db.exec("PRAGMA journal_mode = WAL");
        // Enable foreign key enforcement (SQLite disables by default)
        this.db.exec("PRAGMA foreign_keys = ON");
    }
    /**
     * Get the underlying bun:sqlite Database instance
     */
    get raw() {
        return this.db;
    }
    /**
     * Execute raw SQL (for schema, pragmas, etc.)
     */
    exec(sql) {
        if (this.closed)
            return;
        this.db.exec(sql);
        // Check if this affects any tables
        if (isWriteOperation(sql)) {
            const tables = extractWriteTables(sql);
            if (tables.length > 0) {
                this.invalidate(tables);
            }
        }
    }
    /**
     * Prepare a statement for repeated execution
     */
    prepare(sql) {
        if (this.closed)
            throw new Error('Cannot prepare statement on closed database');
        return this.db.prepare(sql);
    }
    /**
     * Run a write operation (INSERT, UPDATE, DELETE)
     * Auto-invalidates affected queries with row-level granularity when possible
     */
    run(sql, params = []) {
        if (this.closed)
            return undefined;
        const stmt = this.db.prepare(sql);
        const result = stmt.run(...params);
        // Auto-invalidate affected tables
        const tables = extractWriteTables(sql);
        if (tables.length > 0) {
            // Try to extract row filter for fine-grained invalidation
            const rowFilter = extractRowFilter(sql, params);
            if (rowFilter) {
                // Row-level invalidation - only notify subscriptions for this specific row
                this.invalidateWithRowFilter(tables, rowFilter);
            }
            else {
                // Fall back to table-level invalidation
                this.invalidate(tables);
            }
        }
        return result;
    }
    /**
     * Execute a query and return all rows
     */
    query(sql, params = []) {
        if (this.closed)
            return [];
        const stmt = this.db.prepare(sql);
        return stmt.all(...params);
    }
    /**
     * Execute a query and return the first row
     */
    queryOne(sql, params = []) {
        if (this.closed)
            return null;
        const stmt = this.db.prepare(sql);
        return stmt.get(...params) ?? null;
    }
    /**
     * Execute a query and return a single value
     */
    queryValue(sql, params = []) {
        if (this.closed)
            return null;
        const row = this.queryOne(sql, params);
        if (!row)
            return null;
        const values = Object.values(row);
        return values[0] ?? null;
    }
    /**
     * Subscribe to changes on specific tables
     * Returns unsubscribe function
     */
    subscribe(tables, callback) {
        const id = String(this.nextSubscriptionId++);
        const subscription = {
            id,
            tables: new Set(tables.map((t) => t.toLowerCase())),
            callback,
        };
        this.subscriptions.set(id, subscription);
        return () => {
            this.subscriptions.delete(id);
        };
    }
    /**
     * Subscribe to a specific query
     * Automatically detects which tables are involved
     */
    subscribeQuery(sql, callback) {
        const tables = extractReadTables(sql);
        return this.subscribe(tables, callback);
    }
    /**
     * Subscribe to a query with row-level filtering
     * Only triggers when the specific row is modified
     */
    subscribeWithRowFilter(sql, params, callback) {
        const id = String(this.nextSubscriptionId++);
        const tables = extractReadTables(sql);
        const rowFilter = extractRowFilter(sql, params);
        const subscription = {
            id,
            tables: new Set(tables.map((t) => t.toLowerCase())),
            ...(rowFilter && { rowFilters: [rowFilter] }),
            callback,
        };
        this.subscriptions.set(id, subscription);
        return () => {
            this.subscriptions.delete(id);
        };
    }
    /**
     * Invalidate subscriptions for specific rows
     */
    invalidateRows(table, column, values) {
        const normalizedTable = table.toLowerCase();
        const normalizedColumn = column.toLowerCase();
        const valueSet = new Set(values.map(v => String(v)));
        for (const subscription of this.subscriptions.values()) {
            // Check if subscription is for this table
            if (!subscription.tables.has(normalizedTable)) {
                continue;
            }
            // If subscription has row filters, check if any match
            if (subscription.rowFilters && subscription.rowFilters.length > 0) {
                const matches = subscription.rowFilters.some((filter) => filter.table.toLowerCase() === normalizedTable &&
                    filter.column.toLowerCase() === normalizedColumn &&
                    valueSet.has(String(filter.value)));
                if (matches) {
                    subscription.callback();
                }
            }
            else {
                // No row filters - this is a table-level subscription, trigger it
                subscription.callback();
            }
        }
    }
    /**
     * Invalidate with row filter - triggers row-level subscriptions that match
     * and falls back to table-level for subscriptions without row filters
     */
    invalidateWithRowFilter(tables, rowFilter) {
        const normalizedTables = tables.map((t) => t.toLowerCase());
        for (const subscription of this.subscriptions.values()) {
            // Check if subscription depends on any of the invalidated tables
            let affectedTable = null;
            for (const table of normalizedTables) {
                if (subscription.tables.has(table)) {
                    affectedTable = table;
                    break;
                }
            }
            if (!affectedTable) {
                continue;
            }
            // If subscription has row filters, check if this row filter matches
            if (subscription.rowFilters && subscription.rowFilters.length > 0) {
                const matches = subscription.rowFilters.some((filter) => filter.table.toLowerCase() === rowFilter.table.toLowerCase() &&
                    filter.column.toLowerCase() === rowFilter.column.toLowerCase() &&
                    String(filter.value) === String(rowFilter.value));
                if (matches) {
                    subscription.callback();
                }
            }
            else {
                // No row filters - this is a table-level subscription, always trigger
                subscription.callback();
            }
        }
    }
    /**
     * Invalidate queries that depend on the given tables
     * If no tables specified, invalidates all queries
     */
    invalidate(tables) {
        const normalizedTables = tables?.map((t) => t.toLowerCase());
        for (const subscription of this.subscriptions.values()) {
            if (!normalizedTables) {
                // Invalidate all
                subscription.callback();
            }
            else {
                // Check if subscription depends on any of the invalidated tables
                for (const table of normalizedTables) {
                    if (subscription.tables.has(table)) {
                        subscription.callback();
                        break;
                    }
                }
            }
        }
    }
    /**
     * Run a function in a transaction
     */
    transaction(fn) {
        return this.db.transaction(fn)();
    }
    /**
     * Close the database connection
     */
    close() {
        if (!this.closed) {
            this.subscriptions.clear();
            this.db.close();
            this.closed = true;
        }
    }
    /**
     * Check if database is closed
     */
    get isClosed() {
        return this.closed;
    }
}
/**
 * Create a new ReactiveDatabase instance
 */
export function createReactiveDatabase(config) {
    return new ReactiveDatabase(config);
}
//# sourceMappingURL=database.js.map