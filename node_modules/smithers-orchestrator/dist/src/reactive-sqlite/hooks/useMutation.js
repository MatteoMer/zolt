/**
 * useMutation hook for reactive SQLite mutations
 */
import { useCallback, useRef } from 'react';
import { useVersionTracking } from './shared.js';
import { useDatabaseOptional } from './context.js';
/**
 * Hook to execute mutations with automatic query invalidation
 *
 * @example
 * ```tsx
 * // With explicit db
 * function AddUser() {
 *   const { mutate, isLoading } = useMutation(
 *     db,
 *     'INSERT INTO users (name, email) VALUES (?, ?)'
 *   )
 *
 *   const handleAdd = () => {
 *     mutate('Alice', 'alice@example.com')
 *   }
 *
 *   return <button onClick={handleAdd} disabled={isLoading}>Add User</button>
 * }
 *
 * // With context (inside DatabaseProvider)
 * function AddUser() {
 *   const { mutate } = useMutation('INSERT INTO users (name, email) VALUES (?, ?)')
 *   return <button onClick={() => mutate('Alice', 'alice@example.com')}>Add User</button>
 * }
 * ```
 */
export function useMutation(sqlOrDb, sqlOrOptions, optionsOrDb) {
    // Parse overloaded arguments
    const contextDb = useDatabaseOptional();
    let db;
    let sql;
    let options;
    if (typeof sqlOrDb === 'string') {
        // New signature: useMutation(sql, options?, explicitDb?)
        sql = sqlOrDb;
        if (typeof sqlOrOptions === 'object' && sqlOrOptions !== null && !('query' in sqlOrOptions)) {
            // sqlOrOptions is UseMutationOptions
            options = sqlOrOptions;
            db = optionsOrDb ?? contextDb;
        }
        else {
            options = {};
            db = sqlOrOptions ?? contextDb;
        }
        if (!db) {
            throw new Error('useMutation requires either a DatabaseProvider or an explicit db argument');
        }
    }
    else {
        // Legacy signature: useMutation(db, sql, options?)
        db = sqlOrDb;
        sql = sqlOrOptions;
        options = optionsOrDb ?? {};
    }
    const { invalidateTables, onSuccess, onError } = options;
    // Use refs for ephemeral state (per AGENTS.md: no useState)
    const isLoadingRef = useRef(false);
    const errorRef = useRef(null);
    const { invalidateAndUpdate } = useVersionTracking();
    const mutate = useCallback((...params) => {
        isLoadingRef.current = true;
        errorRef.current = null;
        try {
            db.run(sql, params);
            // Manual invalidation if specified
            if (invalidateTables) {
                db.invalidate(invalidateTables);
            }
            onSuccess?.();
        }
        catch (err) {
            errorRef.current = err;
            onError?.(err);
        }
        finally {
            isLoadingRef.current = false;
            invalidateAndUpdate();
        }
    }, [db, sql, invalidateTables, onSuccess, onError, invalidateAndUpdate]);
    const mutateAsync = useCallback(async (...params) => {
        isLoadingRef.current = true;
        errorRef.current = null;
        try {
            db.run(sql, params);
            if (invalidateTables) {
                db.invalidate(invalidateTables);
            }
            onSuccess?.();
        }
        catch (err) {
            errorRef.current = err;
            onError?.(err);
            throw err;
        }
        finally {
            isLoadingRef.current = false;
            invalidateAndUpdate();
        }
    }, [db, sql, invalidateTables, onSuccess, onError, invalidateAndUpdate]);
    return {
        mutate,
        mutateAsync,
        isLoading: isLoadingRef.current,
        error: errorRef.current,
    };
}
//# sourceMappingURL=useMutation.js.map