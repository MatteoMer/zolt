/**
 * Mount lifecycle hooks vendored from react-use
 * https://github.com/streamich/react-use
 * License: MIT
 */
import type { ReactNode } from "react";
import { DependencyList, EffectCallback } from "react";
export interface ExecutionGateProviderProps {
    enabled: boolean;
    children: ReactNode;
}
export declare function ExecutionGateProvider(props: ExecutionGateProviderProps): ReactNode;
export declare function useExecutionGate(): boolean;
/**
 * Runs an effect exactly once when the component mounts.
 * Unlike a raw useEffect with [], this is semantically clear about intent.
 */
export declare const useEffectOnce: (effect: EffectCallback) => void;
/**
 * Runs a callback when the component mounts.
 * More robust than useEffect(() => fn(), []) because it:
 * - Clearly communicates mount-only intent
 * - Is easier to grep for mount behavior
 */
export declare const useMount: (fn: () => void) => void;
/**
 * Runs a callback when the component unmounts.
 * More robust than useEffect cleanup because it:
 * - Always calls the latest version of the callback (via ref)
 * - Avoids stale closure issues that plague normal cleanup functions
 */
export declare const useUnmount: (fn: () => void) => void;
/**
 * Returns true only on the first render, false on all subsequent renders.
 * Useful for skipping effects on mount or detecting initial state.
 */
export declare function useFirstMountState(): boolean;
/**
 * Returns a function that tells you if the component is currently mounted.
 * Essential for avoiding "setState on unmounted component" warnings in async code.
 *
 * @example
 * const isMounted = useMountedState();
 *
 * useEffect(() => {
 *   fetchData().then(data => {
 *     if (isMounted()) {
 *       setData(data);
 *     }
 *   });
 * }, []);
 */
export declare function useMountedState(): () => boolean;
/**
 * Returns the value from the previous render.
 * Returns undefined on the first render.
 *
 * @example
 * const count = useCount();
 * const prevCount = usePrevious(count);
 * // On first render: prevCount is undefined
 * // After count changes: prevCount is the old value
 */
export declare function usePrevious<T>(state: T): T | undefined;
/**
 * Runs an effect when a value changes, with idempotency guarantees.
 * Unlike useEffect with [value], this:
 * - Won't run twice for the same value (handles React strict mode)
 * - Updates the "last seen" value synchronously before running the effect
 * - Runs on first mount (when value first becomes available)
 *
 * @example
 * const ralphCount = ralph?.ralphCount ?? 0;
 *
 * useEffectOnValueChange(ralphCount, () => {
 *   // Runs once when ralphCount changes, idempotent
 *   executeTask();
 * });
 */
export declare function useEffectOnValueChange<T>(value: T, effect: () => void | (() => void), deps?: DependencyList): void;
/**
 * Runs a callback once when execution is enabled.
 * Encapsulates the common pattern of:
 * - executionEnabled check from SmithersProvider context
 * - hasStartedRef idempotency guard
 * - Proper dependency handling
 *
 * @param executionEnabled - Whether execution is enabled (from useSmithers())
 * @param fn - Callback to run once when execution becomes enabled
 * @param deps - Additional dependencies (optional)
 *
 * @example
 * const { executionEnabled } = useSmithers()
 *
 * useExecutionMount(executionEnabled, () => {
 *   // Runs once when executionEnabled becomes true
 *   executeTask();
 * }, [someDep]);
 */
export declare function useExecutionMount(executionEnabled: boolean, fn: () => void, deps?: DependencyList): void;
//# sourceMappingURL=hooks.d.ts.map