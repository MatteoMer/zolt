import Reconciler from 'react-reconciler';
import { DefaultEventPriority } from 'react-reconciler/constants.js';
import { rendererMethods } from './methods.js';
// Track current update priority (avoids hardcoded magic numbers)
let currentUpdatePriority = DefaultEventPriority;
// Re-export rendererMethods for backwards compatibility
export { rendererMethods };
function diffProps(oldProps, newProps) {
    const updatePayload = {};
    let hasChanges = false;
    for (const key of Object.keys(newProps)) {
        if (key === 'children')
            continue;
        if (oldProps[key] !== newProps[key]) {
            updatePayload[key] = newProps[key];
            hasChanges = true;
        }
    }
    for (const key of Object.keys(oldProps)) {
        if (key === 'children')
            continue;
        if (!(key in newProps)) {
            updatePayload[key] = undefined;
            hasChanges = true;
        }
    }
    return hasChanges ? updatePayload : null;
}
/**
 * React Reconciler host configuration for SmithersNode trees.
 * This maps React's reconciliation operations to our SmithersNode structure.
 *
 * Note: Using type assertion because react-reconciler types don't fully match
 * the actual API requirements for React 19.
 */
const hostConfig = {
    // Core configuration
    supportsMutation: true,
    supportsPersistence: false,
    supportsHydration: false,
    isPrimaryRenderer: true,
    // Optional capability flags
    warnsIfNotActing: false,
    supportsResources: false,
    supportsSingletons: false,
    // Timing
    scheduleTimeout: setTimeout,
    cancelTimeout: clearTimeout,
    noTimeout: -1,
    // Context
    getRootHostContext() {
        return {};
    },
    getChildHostContext(parentHostContext) {
        return parentHostContext;
    },
    // Instance creation
    createInstance(type, props) {
        const node = rendererMethods.createElement(type);
        // Apply all props
        for (const [key, value] of Object.entries(props)) {
            if (key !== 'children') {
                rendererMethods.setProperty(node, key, value);
            }
        }
        return node;
    },
    createTextInstance(text) {
        return rendererMethods.createTextNode(text);
    },
    // Tree manipulation (mutation mode)
    appendChild(parent, child) {
        rendererMethods.insertNode(parent, child);
    },
    appendInitialChild(parent, child) {
        rendererMethods.insertNode(parent, child);
    },
    appendChildToContainer(container, child) {
        rendererMethods.insertNode(container, child);
    },
    insertBefore(parent, child, beforeChild) {
        rendererMethods.insertNode(parent, child, beforeChild);
    },
    insertInContainerBefore(container, child, beforeChild) {
        rendererMethods.insertNode(container, child, beforeChild);
    },
    removeChild(parent, child) {
        rendererMethods.removeNode(parent, child);
    },
    removeChildFromContainer(container, child) {
        rendererMethods.removeNode(container, child);
    },
    // Updates
    prepareUpdate(_instance, _type, oldProps, newProps) {
        return diffProps(oldProps, newProps);
    },
    commitUpdate(instance, updatePayloadOrType, typeOrOldProps, oldPropsOrNewProps, _newPropsOrHandle) {
        let updatePayload;
        if (typeof updatePayloadOrType === 'string') {
            updatePayload = diffProps(typeOrOldProps, oldPropsOrNewProps);
        }
        else {
            updatePayload = updatePayloadOrType;
        }
        if (!updatePayload) {
            return;
        }
        for (const [key, value] of Object.entries(updatePayload)) {
            if (value === undefined) {
                // Handle removal: __smithersKey/key stored on instance.key, not props
                if (key === '__smithersKey' || key === 'key') {
                    delete instance.key;
                }
                else {
                    delete instance.props[key];
                }
            }
            else {
                rendererMethods.setProperty(instance, key, value);
            }
        }
    },
    commitTextUpdate(textInstance, _oldText, newText) {
        rendererMethods.replaceText(textInstance, newText);
    },
    // Finalization
    finalizeInitialChildren() {
        return false;
    },
    prepareForCommit() {
        return null;
    },
    resetAfterCommit() {
        // No-op
    },
    // Required methods
    getPublicInstance(instance) {
        return instance;
    },
    shouldSetTextContent() {
        return false;
    },
    clearContainer(container) {
        // Detach all children first to avoid stale parent pointers
        for (const child of container.children) {
            child.parent = null;
        }
        container.children.length = 0; // Preserve array reference
    },
    // Event handling (not used for Smithers)
    preparePortalMount() {
        // No-op
    },
    // Detach/attach (for offscreen trees)
    detachDeletedInstance() {
        // No-op
    },
    // Required for newer React versions
    getCurrentEventPriority() {
        return currentUpdatePriority;
    },
    getInstanceFromNode() {
        return null;
    },
    beforeActiveInstanceBlur() {
        // No-op
    },
    afterActiveInstanceBlur() {
        // No-op
    },
    prepareScopeUpdate() {
        // No-op
    },
    getInstanceFromScope() {
        return null;
    },
    setCurrentUpdatePriority(priority) {
        currentUpdatePriority = priority;
    },
    getCurrentUpdatePriority() {
        return currentUpdatePriority;
    },
    resolveUpdatePriority() {
        return currentUpdatePriority;
    },
    // For microtasks (React 18+)
    supportsMicrotasks: true,
    scheduleMicrotask: typeof queueMicrotask === 'function'
        ? queueMicrotask
        : (callback) => Promise.resolve().then(callback),
    // For hiding/unhiding instances (Suspense boundaries)
    hideInstance() {
        // No-op
    },
    hideTextInstance() {
        // No-op
    },
    unhideInstance() {
        // No-op
    },
    unhideTextInstance() {
        // No-op
    },
    // Resources (React 19+)
    NotPendingTransition: null,
    resetFormInstance() {
        // No-op
    },
    requestPostPaintCallback() {
        // No-op
    },
    shouldAttemptEagerTransition() {
        return false;
    },
    maySuspendCommit() {
        return false;
    },
    preloadInstance() {
        return true;
    },
    startSuspendingCommit() {
        // No-op
    },
    suspendInstance() {
        // No-op
    },
    waitForCommitToBeReady() {
        return null;
    },
};
/**
 * Create the React Reconciler instance
 */
export const SmithersReconciler = Reconciler(hostConfig);
// Enable concurrent features
SmithersReconciler.injectIntoDevTools({
    findFiberByHostInstance: () => null,
    bundleType: process.env.NODE_ENV === 'development' ? 1 : 0,
    version: '19.0.0',
    rendererPackageName: 'smithers-react-renderer',
});
//# sourceMappingURL=host-config.js.map