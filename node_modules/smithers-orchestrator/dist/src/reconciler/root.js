import { SmithersReconciler } from './host-config.js';
import { serialize } from './serialize.js';
import { createOrchestrationPromise, signalOrchestrationErrorByToken, } from '../components/SmithersProvider.js';
function isThenable(value) {
    return value !== null &&
        typeof value === 'object' &&
        typeof value.then === 'function';
}
// Optional legacy global frame capture (not concurrency-safe).
let globalFrameCaptureRoot = null;
/**
 * Opt-in global frame capture for legacy callers (not concurrency-safe).
 */
export function setGlobalFrameCaptureRoot(root) {
    globalFrameCaptureRoot = root;
}
/**
 * Get the globally registered tree serialized as XML (not concurrency-safe).
 */
export function getCurrentTreeXML() {
    if (!globalFrameCaptureRoot)
        return null;
    return globalFrameCaptureRoot.toXML();
}
/**
 * Create a Smithers root for rendering React components to SmithersNode trees.
 */
export function createSmithersRoot() {
    const rootNode = {
        type: 'ROOT',
        props: {},
        children: [],
        parent: null,
    };
    let fiberRoot = null;
    return {
        async mount(App) {
            // Clean up previous render (synchronous in LegacyRoot mode)
            if (fiberRoot) {
                SmithersReconciler.updateContainer(null, fiberRoot, null, () => { });
                // React calls clearContainer/removeNode to clean up children
            }
            // Create a promise that Ralph will resolve when orchestration completes
            // Token-based API ensures concurrency safety across multiple roots
            const { promise: completionPromise, token: orchestrationToken } = createOrchestrationPromise();
            let fatalError = null;
            let errorResolve = null;
            const errorPromise = new Promise((resolve) => {
                errorResolve = resolve;
            });
            const handleFatalError = (error) => {
                fatalError = error;
                if (errorResolve)
                    errorResolve();
                const err = error instanceof Error ? error : new Error(String(error));
                signalOrchestrationErrorByToken(orchestrationToken, err);
            };
            // Check if App returns a Promise
            const result = App();
            let element;
            if (isThenable(result)) {
                element = await result;
            }
            else {
                element = result;
            }
            // Create the fiber root container
            // createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks)
            // NOTE: @types/react-reconciler 0.32 has 8 params, but runtime 0.33 has 10
            fiberRoot = SmithersReconciler.createContainer(rootNode, // containerInfo
            0, // tag: LegacyRoot (ConcurrentRoot = 1)
            null, // hydrationCallbacks
            false, // isStrictMode
            null, // concurrentUpdatesByDefaultOverride
            '', // identifierPrefix
            handleFatalError, // onUncaughtError
            handleFatalError, // onCaughtError
            (error) => console.error('Smithers recoverable error:', error), // onRecoverableError
            null // transitionCallbacks
            );
            // Render the app synchronously
            // LegacyRoot mode (tag: 0) provides synchronous updates by default
            SmithersReconciler.updateContainer(element, fiberRoot, null, () => { });
            // Wait for orchestration to complete or a fatal error to surface
            await Promise.race([completionPromise.catch(() => { }), errorPromise]);
            if (fatalError) {
                throw fatalError;
            }
        },
        render(element) {
            return new Promise((resolve) => {
                // Create fiber root if needed
                if (!fiberRoot) {
                    fiberRoot = SmithersReconciler.createContainer(rootNode, // containerInfo
                    0, // tag: LegacyRoot (ConcurrentRoot = 1)
                    null, // hydrationCallbacks
                    false, // isStrictMode
                    null, // concurrentUpdatesByDefaultOverride
                    '', // identifierPrefix
                    (error) => console.error('Smithers uncaught error:', error), (error) => console.error('Smithers caught error:', error), (error) => console.error('Smithers recoverable error:', error), null // transitionCallbacks
                    );
                }
                // Update container with element (or null to unmount)
                // The callback is invoked when React has finished committing the update
                // LegacyRoot mode (tag: 0) provides synchronous updates by default
                SmithersReconciler.updateContainer(element, fiberRoot, null, () => {
                    resolve();
                });
            });
        },
        getTree() {
            return rootNode;
        },
        dispose() {
            if (fiberRoot) {
                SmithersReconciler.updateContainer(null, fiberRoot, null, () => { });
                fiberRoot = null;
            }
            // Defensive cleanup: recursively clear all parent pointers and empty children array
            function clearTree(node) {
                for (const child of node.children) {
                    child.parent = null;
                    clearTree(child);
                }
                node.children.length = 0;
            }
            clearTree(rootNode);
        },
        toXML() {
            return serialize(rootNode);
        },
    };
}
//# sourceMappingURL=root.js.map