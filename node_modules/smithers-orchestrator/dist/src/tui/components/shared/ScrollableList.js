import { jsx as _jsx } from "react/jsx-runtime";
// Reusable scrollable list component with vim-style navigation
import { useRef } from 'react';
import { useKeyboard } from '@opentui/react';
import { useEffectOnValueChange } from '../../../reconciler/hooks.js';
import { useTuiState } from '../../state.js';
export function ScrollableList({ stateKey, items, renderItem, onSelect, height = 10, focused = true }) {
    const instanceIdRef = useRef(crypto.randomUUID());
    const baseKey = stateKey ?? `tui:scrollable-list:${instanceIdRef.current}`;
    const [selectedIndex, setSelectedIndex] = useTuiState(`${baseKey}:selectedIndex`, 0);
    const [scrollOffset, setScrollOffset] = useTuiState(`${baseKey}:scrollOffset`, 0);
    const clampedSelectedIndex = Math.max(0, Math.min(selectedIndex, items.length - 1));
    useEffectOnValueChange(items.length, () => {
        const maxIndex = Math.max(0, items.length - 1);
        if (selectedIndex > maxIndex) {
            setSelectedIndex(maxIndex);
        }
        const maxOffset = Math.max(0, items.length - height);
        if (scrollOffset > maxOffset) {
            setScrollOffset(maxOffset);
        }
    }, [items.length, selectedIndex, scrollOffset, setSelectedIndex, setScrollOffset, height]);
    useKeyboard((key) => {
        if (!focused)
            return;
        if (key.name === 'j' || key.name === 'down') {
            const maxIndex = Math.max(0, items.length - 1);
            const newIndex = Math.min(clampedSelectedIndex + 1, maxIndex);
            setSelectedIndex(newIndex);
            if (newIndex >= scrollOffset + height) {
                setScrollOffset(newIndex - height + 1);
            }
        }
        else if (key.name === 'k' || key.name === 'up') {
            const newIndex = Math.max(clampedSelectedIndex - 1, 0);
            setSelectedIndex(newIndex);
            if (newIndex < scrollOffset) {
                setScrollOffset(newIndex);
            }
        }
        else if (key.name === 'g') {
            setSelectedIndex(0);
            setScrollOffset(0);
        }
        else if (key.name === 'G' || (key.shift && key.name === 'g')) {
            setSelectedIndex(Math.max(0, items.length - 1));
            setScrollOffset(Math.max(0, items.length - height));
        }
        else if (key.name === 'return') {
            const item = items[clampedSelectedIndex];
            if (item && onSelect) {
                onSelect(item, clampedSelectedIndex);
            }
        }
    });
    const visibleItems = items.slice(scrollOffset, scrollOffset + height);
    return (_jsx("scrollbox", { focused: focused, style: { height }, children: visibleItems.map((item, index) => {
            const actualIndex = scrollOffset + index;
            return (_jsx("box", { children: renderItem(item, actualIndex, actualIndex === clampedSelectedIndex) }, actualIndex));
        }) }));
}
//# sourceMappingURL=ScrollableList.js.map