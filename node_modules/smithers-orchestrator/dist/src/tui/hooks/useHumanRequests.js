// Hook for managing pending human interaction requests
import { useCallback } from 'react';
import { useEffectOnValueChange } from '../../reconciler/hooks.js';
import { useTuiState } from '../state.js';
export function useHumanRequests(db) {
    const [pendingRequests, setPendingRequests] = useTuiState('tui:human:pendingRequests', []);
    const [selectedIndex, setSelectedIndex] = useTuiState('tui:human:selectedIndex', 0);
    const refreshRequests = useCallback(() => {
        try {
            const pending = db.human.listPending();
            setPendingRequests(pending);
        }
        catch {
            // Ignore errors
        }
    }, [db, setPendingRequests]);
    useEffectOnValueChange(db, () => {
        refreshRequests();
        const interval = setInterval(refreshRequests, 500);
        return () => clearInterval(interval);
    }, [refreshRequests]);
    useEffectOnValueChange(pendingRequests.length, () => {
        const maxIndex = Math.max(0, pendingRequests.length - 1);
        if (selectedIndex > maxIndex) {
            setSelectedIndex(maxIndex);
        }
    }, [pendingRequests.length, selectedIndex, setSelectedIndex]);
    const selectRequest = useCallback((index) => {
        const clampedIndex = Math.max(0, Math.min(index, pendingRequests.length - 1));
        setSelectedIndex(clampedIndex);
    }, [pendingRequests.length, setSelectedIndex]);
    const approveRequest = useCallback((response) => {
        const request = pendingRequests[selectedIndex];
        if (!request)
            return;
        try {
            db.human.resolve(request.id, 'approved', response);
            refreshRequests();
        }
        catch {
            // Ignore errors
        }
    }, [db, pendingRequests, selectedIndex, refreshRequests]);
    const rejectRequest = useCallback((response) => {
        const request = pendingRequests[selectedIndex];
        if (!request)
            return;
        try {
            db.human.resolve(request.id, 'rejected', response);
            refreshRequests();
        }
        catch {
            // Ignore errors
        }
    }, [db, pendingRequests, selectedIndex, refreshRequests]);
    const selectedRequest = pendingRequests[selectedIndex] ?? null;
    return {
        pendingRequests,
        selectedIndex,
        selectedRequest,
        selectRequest,
        approveRequest,
        rejectRequest,
        refreshRequests
    };
}
//# sourceMappingURL=useHumanRequests.js.map