import { useEffectOnValueChange } from '../../reconciler/hooks.js';
import { useTuiState } from '../state.js';
const EVENTS_KEY = 'tui:timeline:events';
const EMPTY_EVENTS = [];
export function usePollEvents(db) {
    const [events, setEvents] = useTuiState(EVENTS_KEY, EMPTY_EVENTS);
    useEffectOnValueChange(db, () => {
        const pollEvents = () => {
            try {
                const execution = db.execution.current();
                if (!execution) {
                    setEvents(EMPTY_EVENTS);
                    return;
                }
                const phases = db.query('SELECT id, name, status, created_at as timestamp FROM phases WHERE execution_id = ? ORDER BY created_at DESC LIMIT 20', [execution.id]);
                const agents = db.query('SELECT id, model, status, created_at as timestamp, tokens_input, tokens_output FROM agents WHERE execution_id = ? ORDER BY created_at DESC LIMIT 30', [execution.id]);
                const tools = db.query('SELECT id, tool_name, status, created_at as timestamp, duration_ms FROM tool_calls WHERE execution_id = ? ORDER BY created_at DESC LIMIT 50', [execution.id]);
                const allEvents = [
                    ...phases.map((p) => ({
                        id: p.id,
                        type: 'phase',
                        name: p.name,
                        status: p.status,
                        timestamp: p.created_at
                    })),
                    ...agents.map((a) => ({
                        id: a.id,
                        type: 'agent',
                        name: a.model,
                        status: a.status,
                        timestamp: a.created_at,
                        details: `${a.tokens_input ?? 0}/${a.tokens_output ?? 0} tokens`
                    })),
                    ...tools.map((t) => ({
                        id: t.id,
                        type: 'tool',
                        name: t.tool_name,
                        status: t.status,
                        timestamp: t.created_at,
                        details: t.duration_ms ? `${t.duration_ms}ms` : undefined
                    }))
                ];
                allEvents.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
                setEvents(allEvents);
            }
            catch (err) {
                console.debug('[usePollEvents] Polling error:', err);
            }
        };
        pollEvents();
        const interval = setInterval(pollEvents, 500);
        return () => clearInterval(interval);
    }, [setEvents]);
    return events;
}
//# sourceMappingURL=usePollEvents.js.map