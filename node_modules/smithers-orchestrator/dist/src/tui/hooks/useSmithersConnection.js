// Hook for connecting to Smithers database
// Provides reactive access to execution data
import { useRef } from 'react';
import { createSmithersDB } from '../../db/index.js';
import { useEffectOnValueChange } from '../../reconciler/hooks.js';
import { useTuiState } from '../state.js';
const EMPTY_EXECUTIONS = [];
export function useSmithersConnection(dbPath) {
    const dbRef = useRef(null);
    const pollIntervalRef = useRef(null);
    const keyBase = `tui:connection:${dbPath}`;
    const [isConnected, setIsConnected] = useTuiState(`${keyBase}:connected`, false);
    const [error, setError] = useTuiState(`${keyBase}:error`, null);
    const [currentExecution, setCurrentExecution] = useTuiState(`${keyBase}:currentExecution`, null);
    const [executions, setExecutions] = useTuiState(`${keyBase}:executions`, EMPTY_EXECUTIONS);
    useEffectOnValueChange(dbPath, () => {
        const cleanup = () => {
            if (pollIntervalRef.current) {
                clearInterval(pollIntervalRef.current);
                pollIntervalRef.current = null;
            }
            if (dbRef.current) {
                dbRef.current.close();
                dbRef.current = null;
            }
        };
        cleanup();
        try {
            const fullPath = dbPath.endsWith('.db')
                ? dbPath
                : `${dbPath}/smithers.db`;
            const smithersDb = createSmithersDB({ path: fullPath });
            dbRef.current = smithersDb;
            setIsConnected(true);
            setError(null);
            const pollData = () => {
                try {
                    const current = smithersDb.execution.current();
                    if (current) {
                        setCurrentExecution({
                            ...current,
                            started_at: current.started_at?.toISOString() ?? null,
                            completed_at: current.completed_at?.toISOString() ?? null
                        });
                    }
                    else {
                        setCurrentExecution(null);
                    }
                    const allExecs = smithersDb.execution.list();
                    setExecutions(allExecs.map(e => ({
                        ...e,
                        started_at: e.started_at?.toISOString() ?? null,
                        completed_at: e.completed_at?.toISOString() ?? null
                    })));
                }
                catch {
                    // Ignore polling errors
                }
            };
            pollData();
            pollIntervalRef.current = setInterval(pollData, 500);
        }
        catch (e) {
            setError(e instanceof Error ? e.message : 'Connection failed');
            setIsConnected(false);
            setCurrentExecution(null);
            setExecutions(EMPTY_EXECUTIONS);
        }
        return cleanup;
    }, [dbPath, setCurrentExecution, setError, setExecutions, setIsConnected]);
    return {
        db: dbRef.current,
        isConnected,
        error,
        currentExecution,
        executions
    };
}
//# sourceMappingURL=useSmithersConnection.js.map