//! Lasso Verifier for Instruction Lookup Arguments
//!
//! This module implements the Lasso verifier for verifying instruction lookups
//! in the Jolt zkVM. The verifier checks the Read + RAF sumcheck proof
//! generated by the prover.
//!
//! The verifier checks:
//! 1. Each round polynomial satisfies g_i(0) + g_i(1) = current_claim
//! 2. The final evaluation matches the committed polynomial evaluation
//! 3. The lookup values are consistent with the committed tables
//!
//! Reference: jolt-core/src/zkvm/instruction_lookups/read_raf_checking.rs

const std = @import("std");
const Allocator = std.mem.Allocator;

const prover = @import("prover.zig");
const poly = @import("../../poly/mod.zig");

const LassoParams = prover.LassoParams;
const LassoProof = prover.LassoProof;

/// Lasso verifier state
pub fn LassoVerifier(comptime F: type) type {
    return struct {
        const Self = @This();

        /// Protocol parameters
        params: LassoParams(F),
        /// Current claim to verify
        claim: F,
        /// Current round
        round: usize,
        /// Accumulated challenges
        challenges: []F,
        challenges_len: usize,
        /// Allocator
        allocator: Allocator,

        /// Initialize the verifier with the initial claim
        pub fn init(allocator: Allocator, params: LassoParams(F), initial_claim: F) !Self {
            const max_rounds = params.log_K + params.log_T;
            const challenges = try allocator.alloc(F, max_rounds);
            @memset(challenges, F.zero());

            return Self{
                .params = params,
                .claim = initial_claim,
                .round = 0,
                .challenges = challenges,
                .challenges_len = 0,
                .allocator = allocator,
            };
        }

        pub fn deinit(self: *Self) void {
            self.allocator.free(self.challenges);
        }

        /// Check if verification is complete
        pub fn isComplete(self: *const Self) bool {
            return self.round >= self.params.log_K + self.params.log_T;
        }

        /// Verify a single round of the sumcheck protocol
        ///
        /// Returns the challenge for this round if verification succeeds.
        pub fn verifyRound(self: *Self, round_poly: poly.UniPoly(F)) !F {
            // Check that g(0) + g(1) = current claim
            const g_0 = round_poly.evaluate(F.zero());
            const g_1 = round_poly.evaluate(F.one());
            const sum = g_0.add(g_1);

            if (!sum.eql(self.claim)) {
                return error.SumcheckVerificationFailed;
            }

            // Derive challenge from the round polynomial (Fiat-Shamir)
            const challenge = self.deriveChallenge(round_poly);

            // Record challenge
            self.challenges[self.challenges_len] = challenge;
            self.challenges_len += 1;

            // Update claim for next round: claim = g(challenge)
            self.claim = round_poly.evaluate(challenge);
            self.round += 1;

            return challenge;
        }

        /// Verify the final evaluation
        ///
        /// After all rounds, check that the final claim matches the
        /// prover's claimed evaluation.
        pub fn verifyFinalEval(self: *const Self, claimed_eval: F) !bool {
            if (!self.isComplete()) {
                return error.VerificationIncomplete;
            }

            // The final claim should equal the evaluation at the challenge point
            return self.claim.eql(claimed_eval);
        }

        /// Derive a challenge from a round polynomial (simplified Fiat-Shamir)
        fn deriveChallenge(self: *const Self, round_poly: poly.UniPoly(F)) F {
            var hash: u64 = 0x9e3779b97f4a7c15;
            hash ^= @as(u64, @intCast(self.round));
            hash *%= 0xff51afd7ed558ccd;

            // Mix in current claim
            for (self.claim.limbs) |limb| {
                hash ^= limb;
                hash *%= 0xc4ceb9fe1a85ec53;
            }

            // Mix in polynomial coefficients
            for (round_poly.coeffs) |coeff| {
                for (coeff.limbs) |limb| {
                    hash ^= limb;
                    hash *%= 0xff51afd7ed558ccd;
                }
            }

            hash ^= hash >> 33;
            hash *%= 0xff51afd7ed558ccd;
            hash ^= hash >> 33;

            return F.fromU64(hash);
        }

        /// Get all accumulated challenges
        pub fn getChallenges(self: *const Self) []const F {
            return self.challenges[0..self.challenges_len];
        }

        /// Get the final claim (after all rounds)
        pub fn getFinalClaim(self: *const Self) F {
            return self.claim;
        }
    };
}

/// Verification result
pub const VerificationResult = struct {
    success: bool,
    challenges: []const u8, // Serialized challenges
    final_claim: []const u8, // Serialized final claim
};

/// Verify a complete Lasso proof
pub fn verifyLassoProof(
    comptime F: type,
    allocator: Allocator,
    proof: *const LassoProof(F),
    params: LassoParams(F),
    initial_claim: F,
) !bool {
    var verifier = try LassoVerifier(F).init(allocator, params, initial_claim);
    defer verifier.deinit();

    // Verify each round
    for (proof.round_polys) |round_poly| {
        _ = try verifier.verifyRound(round_poly);
    }

    // Check final evaluation
    return verifier.verifyFinalEval(proof.final_eval);
}

/// Batched verification for multiple Lasso proofs
pub fn batchVerifyLassoProofs(
    comptime F: type,
    allocator: Allocator,
    proofs: []const LassoProof(F),
    params: []const LassoParams(F),
    initial_claims: []const F,
    batching_challenge: F,
) !bool {
    std.debug.assert(proofs.len == params.len);
    std.debug.assert(proofs.len == initial_claims.len);

    // Verify each proof individually (can be parallelized)
    // The challenge_power is used for batching when we implement
    // combined batch verification (future optimization)
    _ = batching_challenge;
    var all_valid = true;

    for (proofs, params, initial_claims) |proof, param, claim| {
        const valid = try verifyLassoProof(F, allocator, &proof, param, claim);
        if (!valid) {
            all_valid = false;
            break;
        }
    }

    return all_valid;
}

test "lasso verifier basic" {
    const F = @import("../../field/mod.zig").BN254Scalar;
    const allocator = std.testing.allocator;

    const r_reduction = [_]F{
        F.fromU64(2),
        F.fromU64(3),
    };

    const params = LassoParams(F).init(
        F.fromU64(5), // gamma
        2, // log_T
        3, // log_K
        &r_reduction,
    );

    var verifier = try LassoVerifier(F).init(allocator, params, F.fromU64(10));
    defer verifier.deinit();

    try std.testing.expectEqual(@as(usize, 0), verifier.round);
    try std.testing.expect(!verifier.isComplete());
}

test "lasso verifier round check" {
    const F = @import("../../field/mod.zig").BN254Scalar;
    const allocator = std.testing.allocator;

    const r_reduction = [_]F{
        F.fromU64(2),
        F.fromU64(3),
    };

    const params = LassoParams(F).init(
        F.fromU64(5),
        2,
        3,
        &r_reduction,
    );

    // Initial claim = 10
    var verifier = try LassoVerifier(F).init(allocator, params, F.fromU64(10));
    defer verifier.deinit();

    // Create a valid round polynomial: g(X) = 4 + 2X
    // g(0) = 4, g(1) = 6, g(0) + g(1) = 10 ✓
    const coeffs = try allocator.alloc(F, 2);
    defer allocator.free(coeffs);
    coeffs[0] = F.fromU64(4);
    coeffs[1] = F.fromU64(2);

    const round_poly = poly.UniPoly(F){
        .coeffs = coeffs,
        .allocator = allocator,
    };

    // Verify the round
    const challenge = try verifier.verifyRound(round_poly);
    _ = challenge;

    // Verifier should advance
    try std.testing.expectEqual(@as(usize, 1), verifier.round);
}

test "lasso verifier invalid round" {
    const F = @import("../../field/mod.zig").BN254Scalar;
    const allocator = std.testing.allocator;

    const r_reduction = [_]F{
        F.fromU64(2),
        F.fromU64(3),
    };

    const params = LassoParams(F).init(
        F.fromU64(5),
        2,
        3,
        &r_reduction,
    );

    // Initial claim = 10
    var verifier = try LassoVerifier(F).init(allocator, params, F.fromU64(10));
    defer verifier.deinit();

    // Create an INVALID round polynomial: g(X) = 4 + 3X
    // g(0) = 4, g(1) = 7, g(0) + g(1) = 11 ≠ 10 ✗
    const coeffs = try allocator.alloc(F, 2);
    defer allocator.free(coeffs);
    coeffs[0] = F.fromU64(4);
    coeffs[1] = F.fromU64(3);

    const round_poly = poly.UniPoly(F){
        .coeffs = coeffs,
        .allocator = allocator,
    };

    // Verification should fail
    const result = verifier.verifyRound(round_poly);
    try std.testing.expectError(error.SumcheckVerificationFailed, result);
}
